[{"path":"https://emmaskarstein.github.io/inlamemi/articles/Framingham_heart_study.html","id":"first-example-a-logistic-regression-model-with-repeated-measurements","dir":"Articles","previous_headings":"","what":"First example: A logistic regression model with repeated measurements","title":"Influence of systolic blood pressure on coronary heart disease","text":"data model example also used Muff et al (2015), information measurement error model can found . model identical, example just shows can implemented inlamemi. example, fit logistic regression model whether patient heart disease, using systolic blood pressure (SBP) smoking status covariates. SBP measured error, repeated measurements, like feed measurements SBP model. can done easily inlamemi package. formula main model interest \\[ \\text{logit}\\{\\texttt{disease}_i\\} = \\beta_0 + \\beta_{\\texttt{sbp}} \\texttt{sbp}_i + \\beta_{\\texttt{smoking}} \\texttt{smoking}_i, \\] formula imputation model \\[ \\texttt{sbp}_i = \\alpha_0 + \\alpha_{\\texttt{smoking}} \\texttt{smoking}_i + \\varepsilon_i^{\\texttt{sbp}}. \\] addition, course also classical measurement error model describes actual error SBP measurements, since repeated measurements actually two: \\[ \\begin{align} \\texttt{sbp}^1_i = \\texttt{sbp}_i + u_i^{1}, \\\\ \\texttt{sbp}^2_i = \\texttt{sbp}_i + u_i^{2}, \\end{align} \\] \\(u_i^{1}, u_i^{2} \\sim N(0, \\tau_u)\\) measurement error terms. can call fit_inlamemi function directly formulas model interest imputation model. Also note repeated measurements argument, must set TRUE ensure model specified correctly. give precision error term measurement error model prior, error term imputation model prior. default R-INLA, fixed effects given Gaussian priors mean \\(0\\) precision \\(0.001\\). re-assign precisions \\(0.01\\), keep means 0 (therefore specified control.fixed argument). model fit can look summary.  comparison, can also fit “naive” model, , model ignores measurement error SBP. model, take average two SBP measurements use SBP variable. can compare estimated coefficients models.","code":"framingham_model <- fit_inlamemi(formula_moi = disease ~ sbp + smoking,                                formula_imp = sbp ~ smoking,                                family_moi = \"binomial\",                                 data = framingham,                                error_type = \"classical\",                                 repeated_observations = TRUE,                                prior.prec.classical = c(100, 1),                                prior.prec.imp = c(10, 1),                                prior.beta.error = c(0, 0.01),                                initial.prec.classical = 100,                                initial.prec.imp = 10,                                control.fixed = list(                                  prec = list(beta.0 = 0.01,                                               beta.smoking = 0.01,                                               alpha.0 = 0.01,                                               alpha.smoking = 0.01))) summary(framingham_model) #> Formula for model of interest:  #> disease ~ sbp + smoking #>  #> Formula for imputation model:  #> sbp ~ smoking #>  #> Error types:  #> [1] \"classical\" #>  #> Fixed effects for model of interest:  #>                    mean        sd 0.025quant   0.5quant 0.975quant       mode #> beta.0       -2.3632167 0.2707248 -2.8955728 -2.3627007 -1.8337882 -2.3626951 #> beta.smoking  0.3999613 0.2996516 -0.1872857  0.3998374  0.9879154  0.3998372 #>  #> Coefficient for variable with measurement error and/or missingness:  #>             mean       sd 0.025quant 0.5quant 0.975quant     mode #> beta.sbp 1.89687 0.574248  0.7920293 1.888275   3.052752 1.851331 #>  #> Fixed effects for imputation model:  #>                          mean         sd  0.025quant    0.5quant 0.975quant #> alpha.sbp.0        0.01454297 0.01858779 -0.02191733  0.01454297 0.05100326 #> alpha.sbp.smoking -0.01958474 0.02157015 -0.06189500 -0.01958474 0.02272552 #>                          mode #> alpha.sbp.0        0.01454297 #> alpha.sbp.smoking -0.01958474 #>  #> Model hyperparameters (apart from beta.sbp):  #>                                       mean       sd 0.025quant 0.5quant #> Precision for sbp classical model 75.90848 3.687485   68.87052 75.83194 #> Precision for sbp imp model       19.90276 1.235353   17.57558 19.86663 #>                                   0.975quant     mode #> Precision for sbp classical model   83.38562 75.70678 #> Precision for sbp imp model         22.43761 19.79912 plot(framingham_model) framingham$sbp <- (framingham$sbp1 + framingham$sbp2)/2 naive_model <- inla(formula = disease ~ sbp + smoking,                     family = \"binomial\",                      data = framingham) naive_model$summary.fixed #>                   mean        sd 0.025quant   0.5quant 0.975quant       mode #> (Intercept) -2.3547260 0.2692644 -2.8824744 -2.3547260 -1.8269775 -2.3547260 #> sbp          1.6686898 0.4937448  0.7009677  1.6686898  2.6364119  1.6686898 #> smoking      0.3972558 0.2992218 -0.1892081  0.3972558  0.9837197  0.3972558 #>             kld #> (Intercept)   0 #> sbp           0 #> smoking       0 naive_result <- naive_model$summary.fixed rownames(naive_result) <- c(\"beta.0\", \"beta.sbp\", \"beta.smoking\") naive_result$variable <- rownames(naive_result) me_result <- rbind(summary(framingham_model)$moi_coef[1:6],                     summary(framingham_model)$error_coef[1:6]) me_result$variable <- rownames(me_result) results <- dplyr::bind_rows(naive = naive_result, me_adjusted = me_result, .id = \"model\")  ggplot(results, aes(x = mean, y = model, color = variable)) +   geom_point() +   geom_linerange(aes(xmin = `0.025quant`, xmax = `0.975quant`)) +   facet_grid(~ variable, scales = \"free_x\") +   theme_bw()"},{"path":"https://emmaskarstein.github.io/inlamemi/articles/Framingham_heart_study.html","id":"second-example-heteroscedastic-measurement-error-and-interaction-between-error-variable-and-error-free-variable","dir":"Articles","previous_headings":"","what":"Second example: Heteroscedastic measurement error and interaction between error variable and error free variable","title":"Influence of systolic blood pressure on coronary heart disease","text":"example, artificially increase measurement error smoking group order study model homoscedastic measurement error. model example identical Muff & Keller (2015)","code":"framingham2 <- framingham n <- nrow(framingham2)  set.seed(1) framingham2$sbp1 <- framingham$sbp1 +    ifelse(framingham2$smoking == 1, rnorm(n, 0, 0.117), 0) framingham2$sbp2 <- framingham$sbp2 +    ifelse(framingham2$smoking == 1, rnorm(n, 0, 0.117), 0)  # Or:  #framingham2 <- read.table(\"../data-raw/fram_data_case2.txt\", header=T) #names(framingham2) <- c(\"disease\", \"sbp1\", \"sbp2\", \"smoking\")  #framingham2$sbp <- (framingham2$sbp1 + framingham2$sbp2)/2 error_scaling <- c(1/(1+9*framingham2$smoking), 1/(1+9*framingham2$smoking)) # Homoscedastic ME modeled as homoscedastic ME (correct) framingham_model2.1 <- fit_inlamemi(formula_moi = disease ~ sbp:smoking,                                formula_imp = sbp ~ smoking,                                family_moi = \"binomial\",                                 data = framingham,                                error_type = \"classical\",                                 repeated_observations = TRUE,                                prior.prec.classical = c(100, 1),                                prior.prec.imp = c(10, 1),                                prior.beta.error = c(0, 0.01),                                initial.prec.classical = 100,                                initial.prec.imp = 10,                                control.fixed = list(                                  prec = list(beta.0 = 0.01,                                               beta.smoking = 0.01,                                               alpha.0 = 0.01,                                               alpha.smoking = 0.01)))  # Heteroscedastic ME modeled as heteroscedastic ME (correct) framingham_model2.2 <- fit_inlamemi(formula_moi = disease ~ sbp:smoking,                                formula_imp = sbp ~ smoking,                                family_moi = \"binomial\",                                 data = framingham2,                                error_type = \"classical\",                                 repeated_observations = TRUE,                                classical_error_scaling = error_scaling,                                prior.prec.classical = c(100, 1),                                prior.prec.imp = c(10, 1),                                prior.beta.error = c(0, 0.01),                                initial.prec.classical = 100,                                initial.prec.imp = 10,                                control.fixed = list(                                  prec = list(beta.0 = 0.01,                                               beta.smoking = 0.01,                                               alpha.0 = 0.01,                                               alpha.smoking = 0.01)))  # Heteroscedastic ME modeled as homoscedastic ME (incorrect) framingham_model2.3 <- fit_inlamemi(formula_moi = disease ~ sbp:smoking,                                formula_imp = sbp ~ smoking,                                family_moi = \"binomial\",                                 data = framingham2,                                error_type = \"classical\",                                 repeated_observations = TRUE,                                prior.prec.classical = c(100, 1),                                prior.prec.imp = c(10, 1),                                prior.beta.error = c(0, 0.01),                                initial.prec.classical = 100,                                initial.prec.imp = 10,                                control.fixed = list(                                  prec = list(beta.0 = 0.01,                                               beta.smoking = 0.01,                                               alpha.0 = 0.01,                                               alpha.smoking = 0.01)))  framingham_model2.5 <- fit_inlamemi(formula_moi = disease ~ sbp:smoking,                                formula_imp = sbp ~ smoking,                                family_moi = \"binomial\",                                 data = framingham2,                                error_type = \"classical\",                                 repeated_observations = TRUE,                                classical_error_scaling = c(rep(10^(-12), 2*n)),                                prior.prec.classical = c(100, 1),                                prior.prec.imp = c(10, 1),                                prior.beta.error = c(0, 0.01),                                initial.prec.classical = 100,                                initial.prec.imp = 10,                                control.fixed = list(                                  prec = list(beta.0 = 0.01,                                               beta.smoking = 0.01,                                               alpha.0 = 0.01,                                               alpha.smoking = 0.01)))  plot(framingham_model2.1) plot(framingham_model2.2) plot(framingham_model2.3) plot(framingham_model2.5) framingham_model2.1$summary.hyperpar #>                                                 mean       sd 0.025quant #> Precision for the Gaussian observations[2] 75.985476 3.755864 69.1985359 #> Precision for the Gaussian observations[3] 19.876250 1.235412 17.5445036 #> Beta for beta.smokingsbp                   -1.537548 1.299590 -4.1957195 #> Beta for beta.sbp                           3.096002 1.153201  0.9119081 #>                                             0.5quant 0.975quant      mode #> Precision for the Gaussian observations[2] 75.783665  83.967668 75.120632 #> Precision for the Gaussian observations[3] 19.841656  22.406712 19.780515 #> Beta for beta.smokingsbp                   -1.503762   0.917168 -1.353095 #> Beta for beta.sbp                           3.067820   5.449519  2.942687 framingham_model2.2$summary.hyperpar #>                                                  mean       sd 0.025quant #> Precision for the Gaussian observations[2] 157.087339 7.227804 143.261533 #> Precision for the Gaussian observations[3]  22.132066 1.653050  19.081344 #> Beta for beta.smokingsbp                    -0.500449 1.445493  -3.372930 #> Beta for beta.sbp                            2.918584 1.114874   0.745898 #>                                               0.5quant 0.975quant        mode #> Precision for the Gaussian observations[2] 156.9478514 171.713171 156.7264357 #> Precision for the Gaussian observations[3]  22.0621020  25.586458  21.9053551 #> Beta for beta.smokingsbp                    -0.4913114   2.318463  -0.4530052 #> Beta for beta.sbp                            2.9110406   5.135525   2.8793829 framingham_model2.3$summary.hyperpar #>                                                 mean       sd 0.025quant #> Precision for the Gaussian observations[2] 45.164769 2.190592 41.0024135 #> Precision for the Gaussian observations[3] 19.174942 1.275577 16.7775257 #> Beta for beta.smokingsbp                   -1.606883 1.422704 -4.4610246 #> Beta for beta.sbp                           3.314641 1.270508  0.8607154 #>                                             0.5quant 0.975quant      mode #> Precision for the Gaussian observations[2] 45.112902  49.625435 45.012027 #> Precision for the Gaussian observations[3] 19.135761  21.797531 19.064256 #> Beta for beta.smokingsbp                   -1.588824   1.140299 -1.511730 #> Beta for beta.sbp                           3.298720   5.862846  3.230784 framingham_model2.5$summary.hyperpar #>                                                    mean          sd #> Precision for the Gaussian observations[2] 727.86391588 8.243609488 #> Precision for the Gaussian observations[3]   9.72330082 0.099598202 #> Beta for beta.smokingsbp                    -0.31336915 0.011619378 #> Beta for beta.sbp                           -0.04731766 0.006487732 #>                                              0.025quant     0.5quant #> Precision for the Gaussian observations[2] 709.04250946 728.85463481 #> Precision for the Gaussian observations[3]   9.55954533   9.71500428 #> Beta for beta.smokingsbp                    -0.33060831  -0.31478640 #> Beta for beta.sbp                           -0.05993532  -0.04738113 #>                                              0.975quant         mode #> Precision for the Gaussian observations[2] 740.53803551 734.19711085 #> Precision for the Gaussian observations[3]   9.94634214   9.67024231 #> Beta for beta.smokingsbp                    -0.28640230  -0.32256921 #> Beta for beta.sbp                           -0.03427747  -0.04769691"},{"path":"https://emmaskarstein.github.io/inlamemi/articles/Visualize_model_structure.html","id":"defining-the-model-formula-structured-data-stacks","dir":"Articles","previous_headings":"","what":"Defining the model: formula + structured data stacks","title":"How are the models structured?","text":"using inlamemi package, user specifies two formulas, one main model interest, one imputation model. just two sub-models, also least one measurement error model hood. models need communicated inla() function, takes one formula-argument. formula terms simply added together one big formula, order communicate inla function terms apply sub-model, supply data structured matrices layer matrix shows terms “activated” layer. practice, can done either manually constructed matrices (see instance https://emmaskarstein.github.io/Missing-data--measurement-error/simulation_example.html detailed explanation ), one can use inla.stack function specify modules sub-model separately, stack together. inlamemi package, structure data using inla.stacks. outcome , just makes construction bit generalizable. stack construction done function make_inlamemi_stacks, called fit_inlamemi, function user typically need interact . function show_data_structure converts stack object LaTeX matrices, shows first last row sub-model, making easier get clear overview structure model. Now, take look matrices two different models: one Berkson measurement error, one without.","code":"f_moi <- y ~ x + z f_imp <- x ~ z"},{"path":"https://emmaskarstein.github.io/inlamemi/articles/Visualize_model_structure.html","id":"structure-for-a-classical-measurement-error-model","dir":"Articles","previous_headings":"","what":"Structure for a classical measurement error model","title":"How are the models structured?","text":"models fit inlamemi contain classical measurement error layer, even measurement error, classical model needed technical reasons order covariate imputation. cases classical , scale classical error precision large, thus effectively “turning ” error adjustment keeping imputation model. example, hierarchical model consists main model interest: \\[ \\boldsymbol{y} = \\beta_0 + \\beta_x \\boldsymbol{x} + \\beta_z \\boldsymbol{z} + \\boldsymbol{\\varepsilon} \\ , \\quad \\boldsymbol{\\varepsilon} \\sim N(\\boldsymbol{0}, \\tau_y\\boldsymbol{}) \\ , \\] classical error model: \\[   \\boldsymbol{w} = \\boldsymbol{x} + \\boldsymbol{u}_c \\ , \\quad \\boldsymbol{u}_c \\sim N(\\boldsymbol{0}, \\tau_{u_c}\\boldsymbol{}) \\ , \\] imputation model: \\[ \\boldsymbol{x} = \\alpha_0 + \\alpha_z \\boldsymbol{z} + \\boldsymbol{\\varepsilon}_x \\ , \\quad \\boldsymbol{\\varepsilon}_x \\sim N(\\boldsymbol{0}, \\tau_x\\boldsymbol{}) \\ . \\] need rewritten R-INLA latent effects left hand side: \\[ \\begin{align}   \\boldsymbol{y} &= \\beta_0 + \\beta_x \\boldsymbol{x} + \\beta_z \\boldsymbol{z} + \\boldsymbol{\\varepsilon} \\ , \\quad &\\boldsymbol{\\varepsilon} \\sim N(\\boldsymbol{0}, \\tau_y\\boldsymbol{}) \\ , \\\\   \\boldsymbol{w} &= \\boldsymbol{x} + \\boldsymbol{u}_c \\ , \\quad &\\boldsymbol{u}_c \\sim N(\\boldsymbol{0}, \\tau_{u_c}\\boldsymbol{}) \\ , \\\\   \\boldsymbol{0} &= -\\boldsymbol{x} + \\alpha_0 + \\alpha_z \\boldsymbol{z} + \\boldsymbol{\\varepsilon}_x \\ , \\quad &\\boldsymbol{\\varepsilon}_x \\sim N(\\boldsymbol{0}, \\tau_x\\boldsymbol{}) \\ . \\end{align} \\] can construct necessary stacks model using make_inlamemi_stacks function: can visualize data stacks show_data_structure function: LaTeX code stored classical_summary$matrix_string. want display matrices rmarkdown document, can use cat function, just remember set results = 'asis' chunk option: \\[\\underbrace{\\begin{bmatrix} 10.81 & \\texttt{NA} & \\texttt{NA}\\\\ \\vdots & \\vdots & \\vdots\\\\ 6.18 & \\texttt{NA} & \\texttt{NA}\\\\ \\texttt{NA} & 4.98 & \\texttt{NA}\\\\ \\vdots & \\vdots & \\vdots\\\\ \\texttt{NA} & 1.46 & \\texttt{NA}\\\\ \\texttt{NA} & \\texttt{NA} & 0\\\\ \\vdots & \\vdots & \\vdots\\\\ \\texttt{NA} & \\texttt{NA} & 0\\\\ \\end{bmatrix}}_{\\texttt{Y}} = \\beta_{0}\\underbrace{\\begin{bmatrix} 1\\\\ \\vdots\\\\ 1\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\end{bmatrix}}_{\\texttt{beta.0}} + \\beta_{x}\\underbrace{\\begin{bmatrix} 1\\\\ \\vdots\\\\ 1000\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\end{bmatrix}}_{\\texttt{beta.x}} + \\beta_{z}\\underbrace{\\begin{bmatrix} 0.98\\\\ \\vdots\\\\ 0.77\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\end{bmatrix}}_{\\texttt{beta.z}} + \\underbrace{\\begin{bmatrix} \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ 1\\\\ \\vdots\\\\ 1000\\\\ -1\\\\ \\vdots\\\\ -1000\\\\ \\end{bmatrix}}_{\\texttt{id.x}} + \\alpha_{x,0}\\underbrace{\\begin{bmatrix} \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ 1\\\\ \\vdots\\\\ 1\\\\ \\end{bmatrix}}_{\\texttt{alpha.x.0}} + \\alpha_{x,z}\\underbrace{\\begin{bmatrix} \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ 0.98\\\\ \\vdots\\\\ 0.77\\\\ \\end{bmatrix}}_{\\texttt{alpha.x.z}}\\]","code":"classical_stack <- make_inlamemi_stacks(data = simple_data,                                       formula_moi = f_moi,                                       formula_imp = f_imp,                                       error_type = \"classical\") classical_summary <- show_data_structure(classical_stack) ```{r, results='asis'} cat(classical_summary$matrix_string) ```"},{"path":"https://emmaskarstein.github.io/inlamemi/articles/Visualize_model_structure.html","id":"structure-for-berkson-and-classical-measurement-error-model","dir":"Articles","previous_headings":"","what":"Structure for Berkson and classical measurement error model","title":"How are the models structured?","text":"Next, consider case Berkson measurement error, along either classical , missingness covariate (whether classical , missingness makes difference example, affects scaling measurement error precision). example, hierarchical model consists four levels; main model interest: \\[ \\boldsymbol{y} = \\beta_0 + \\beta_x \\boldsymbol{x} + \\beta_z \\boldsymbol{z} + \\boldsymbol{\\varepsilon} \\ , \\quad \\boldsymbol{\\varepsilon} \\sim N(\\boldsymbol{0}, \\tau_y\\boldsymbol{}) \\ , \\] Berkson error model: \\[   \\boldsymbol{x} = \\boldsymbol{r} + \\boldsymbol{u}_b \\ , \\quad \\boldsymbol{u}_b \\sim N(\\boldsymbol{0}, \\tau_{u_b}\\boldsymbol{}) \\ , \\] classical error model: \\[   \\boldsymbol{w} = \\boldsymbol{r} + \\boldsymbol{u}_c \\ , \\quad \\boldsymbol{u}_c \\sim N(\\boldsymbol{0}, \\tau_{u_c}\\boldsymbol{}) \\ , \\] imputation model: \\[ \\boldsymbol{r} = \\alpha_0 + \\alpha_z \\boldsymbol{z} + \\boldsymbol{\\varepsilon}_r \\ , \\quad \\boldsymbol{\\varepsilon}_r \\sim N(\\boldsymbol{0}, \\tau_r\\boldsymbol{}) \\ . \\] Notice now new latent variable \\(\\boldsymbol{r}\\), serves link sub-models corresponds variable subject Berkson error yet classical error added. Rewritten R-INLA: \\[ \\begin{align}   \\boldsymbol{y} &= \\beta_0 + \\beta_x \\boldsymbol{x} + \\beta_z \\boldsymbol{z} + \\boldsymbol{\\varepsilon} \\ , \\quad &\\boldsymbol{\\varepsilon} &\\sim N(\\boldsymbol{0}, \\tau_y\\boldsymbol{}) \\ , \\\\   \\boldsymbol{0} &= -\\boldsymbol{x} + \\boldsymbol{r} + \\boldsymbol{u}_b \\ , \\quad & \\boldsymbol{u}_b &\\sim N(\\boldsymbol{0}, \\tau_{u_b}\\boldsymbol{}) \\ , \\\\   \\boldsymbol{w} &= \\boldsymbol{r} + \\boldsymbol{u}_c \\ , \\quad &\\boldsymbol{u}_c &\\sim N(\\boldsymbol{0}, \\tau_{u_c}\\boldsymbol{}) \\ , \\\\   \\boldsymbol{0} &= -\\boldsymbol{r} + \\alpha_0 + \\alpha_z \\boldsymbol{z} + \\boldsymbol{\\varepsilon}_r \\ , \\quad &\\boldsymbol{\\varepsilon}_r &\\sim N(\\boldsymbol{0}, \\tau_r\\boldsymbol{}) \\ . \\end{align} \\] Just like , construct stacks: visualize resulting matrices: \\[\\underbrace{\\begin{bmatrix} 10.81 & \\texttt{NA} & \\texttt{NA} & \\texttt{NA}\\\\ \\vdots & \\vdots & \\vdots & \\vdots\\\\ 6.18 & \\texttt{NA} & \\texttt{NA} & \\texttt{NA}\\\\ \\texttt{NA} & 0 & \\texttt{NA} & \\texttt{NA}\\\\ \\vdots & \\vdots & \\vdots & \\vdots\\\\ \\texttt{NA} & 0 & \\texttt{NA} & \\texttt{NA}\\\\ \\texttt{NA} & \\texttt{NA} & 4.98 & \\texttt{NA}\\\\ \\vdots & \\vdots & \\vdots & \\vdots\\\\ \\texttt{NA} & \\texttt{NA} & 1.46 & \\texttt{NA}\\\\ \\texttt{NA} & \\texttt{NA} & \\texttt{NA} & 0\\\\ \\vdots & \\vdots & \\vdots & \\vdots\\\\ \\texttt{NA} & \\texttt{NA} & \\texttt{NA} & 0\\\\ \\end{bmatrix}}_{\\texttt{Y}} = \\beta_{0}\\underbrace{\\begin{bmatrix} 1\\\\ \\vdots\\\\ 1\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\end{bmatrix}}_{\\texttt{beta.0}} + \\beta_{x}\\underbrace{\\begin{bmatrix} 1\\\\ \\vdots\\\\ 1000\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\end{bmatrix}}_{\\texttt{beta.x}} + \\beta_{z}\\underbrace{\\begin{bmatrix} 0.98\\\\ \\vdots\\\\ 0.77\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\end{bmatrix}}_{\\texttt{beta.z}} + \\underbrace{\\begin{bmatrix} \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ -1\\\\ \\vdots\\\\ -1000\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\end{bmatrix}}_{\\texttt{id.x}} + \\underbrace{\\begin{bmatrix} \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ 1\\\\ \\vdots\\\\ 1000\\\\ 1\\\\ \\vdots\\\\ 1000\\\\ -1\\\\ \\vdots\\\\ -1000\\\\ \\end{bmatrix}}_{\\texttt{id.r}} + \\alpha_{x,0}\\underbrace{\\begin{bmatrix} \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ 1\\\\ \\vdots\\\\ 1\\\\ \\end{bmatrix}}_{\\texttt{alpha.x.0}} + \\alpha_{x,z}\\underbrace{\\begin{bmatrix} \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ 0.98\\\\ \\vdots\\\\ 0.77\\\\ \\end{bmatrix}}_{\\texttt{alpha.x.z}}\\] see, things change added another model level, leads another column response matrix, additionally new column latent effect \\(\\boldsymbol{r}\\).","code":"berkson_stack <- make_inlamemi_stacks(data = simple_data,               formula_moi = f_moi,               formula_imp = f_imp,               error_type = c(\"classical\", \"berkson\", \"missing\")) berkson_summary <- show_data_structure(berkson_stack)"},{"path":"https://emmaskarstein.github.io/inlamemi/articles/Visualize_model_structure.html","id":"accessing-the-stacks-from-the-model-object","dir":"Articles","previous_headings":"","what":"Accessing the stacks from the model object","title":"How are the models structured?","text":"data stacks generated make_inlamemi_stacks inside fit_inlamemi also returned inlamemi model object, don’t need run make_inlamemi_stacks . access stacks model object: \\[\\underbrace{\\begin{bmatrix} 10.81 & \\texttt{NA} & \\texttt{NA} & \\texttt{NA}\\\\ \\vdots & \\vdots & \\vdots & \\vdots\\\\ 6.18 & \\texttt{NA} & \\texttt{NA} & \\texttt{NA}\\\\ \\texttt{NA} & 0 & \\texttt{NA} & \\texttt{NA}\\\\ \\vdots & \\vdots & \\vdots & \\vdots\\\\ \\texttt{NA} & 0 & \\texttt{NA} & \\texttt{NA}\\\\ \\texttt{NA} & \\texttt{NA} & 4.98 & \\texttt{NA}\\\\ \\vdots & \\vdots & \\vdots & \\vdots\\\\ \\texttt{NA} & \\texttt{NA} & 1.46 & \\texttt{NA}\\\\ \\texttt{NA} & \\texttt{NA} & \\texttt{NA} & 0\\\\ \\vdots & \\vdots & \\vdots & \\vdots\\\\ \\texttt{NA} & \\texttt{NA} & \\texttt{NA} & 0\\\\ \\end{bmatrix}}_{\\texttt{Y}} = \\beta_{0}\\underbrace{\\begin{bmatrix} 1\\\\ \\vdots\\\\ 1\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\end{bmatrix}}_{\\texttt{beta.0}} + \\beta_{x}\\underbrace{\\begin{bmatrix} 1\\\\ \\vdots\\\\ 1000\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\end{bmatrix}}_{\\texttt{beta.x}} + \\beta_{z}\\underbrace{\\begin{bmatrix} 0.98\\\\ \\vdots\\\\ 0.77\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\end{bmatrix}}_{\\texttt{beta.z}} + \\underbrace{\\begin{bmatrix} \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ -1\\\\ \\vdots\\\\ -1000\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\end{bmatrix}}_{\\texttt{id.x}} + \\underbrace{\\begin{bmatrix} \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ 1\\\\ \\vdots\\\\ 1000\\\\ 1\\\\ \\vdots\\\\ 1000\\\\ -1\\\\ \\vdots\\\\ -1000\\\\ \\end{bmatrix}}_{\\texttt{id.r}} + \\alpha_{x,0}\\underbrace{\\begin{bmatrix} \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ 1\\\\ \\vdots\\\\ 1\\\\ \\end{bmatrix}}_{\\texttt{alpha.x.0}} + \\alpha_{x,z}\\underbrace{\\begin{bmatrix} \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ 0.98\\\\ \\vdots\\\\ 0.77\\\\ \\end{bmatrix}}_{\\texttt{alpha.x.z}}\\] \\[\\underbrace{\\begin{bmatrix} 7.9 & \\texttt{NA} & \\texttt{NA} & \\texttt{NA}\\\\ \\vdots & \\vdots & \\vdots & \\vdots\\\\ 2.58 & \\texttt{NA} & \\texttt{NA} & \\texttt{NA}\\\\ \\texttt{NA} & 2.31 & \\texttt{NA} & \\texttt{NA}\\\\ \\vdots & \\vdots & \\vdots & \\vdots\\\\ \\texttt{NA} & \\texttt{NA} & \\texttt{NA} & \\texttt{NA}\\\\ \\texttt{NA} & \\texttt{NA} & 0 & \\texttt{NA}\\\\ \\vdots & \\vdots & \\vdots & \\vdots\\\\ \\texttt{NA} & \\texttt{NA} & 0 & \\texttt{NA}\\\\ \\texttt{NA} & \\texttt{NA} & \\texttt{NA} & 0\\\\ \\vdots & \\vdots & \\vdots & \\vdots\\\\ \\texttt{NA} & \\texttt{NA} & \\texttt{NA} & 1\\\\ \\end{bmatrix}}_{\\texttt{Y}} = \\beta_{0}\\underbrace{\\begin{bmatrix} 1\\\\ \\vdots\\\\ 1\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\end{bmatrix}}_{\\texttt{beta.0}} + \\beta_{x}\\underbrace{\\begin{bmatrix} 1\\\\ \\vdots\\\\ 1000\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\end{bmatrix}}_{\\texttt{beta.x}} + \\beta_{z1}\\underbrace{\\begin{bmatrix} 0.98\\\\ \\vdots\\\\ 0.77\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\end{bmatrix}}_{\\texttt{beta.z1}} + \\beta_{z2}\\underbrace{\\begin{bmatrix} -0.05\\\\ \\vdots\\\\ -0.72\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\end{bmatrix}}_{\\texttt{beta.z2}} + \\underbrace{\\begin{bmatrix} \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ 1\\\\ \\vdots\\\\ 1000\\\\ -1\\\\ \\vdots\\\\ -1000\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\end{bmatrix}}_{\\texttt{id.x}} + \\alpha_{x,0}\\underbrace{\\begin{bmatrix} \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ 1\\\\ \\vdots\\\\ 1\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\end{bmatrix}}_{\\texttt{alpha.x.0}} + \\alpha_{x,z1}\\underbrace{\\begin{bmatrix} \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ 0.98\\\\ \\vdots\\\\ 0.77\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\end{bmatrix}}_{\\texttt{alpha.x.z1}} + \\gamma_{x,0}\\underbrace{\\begin{bmatrix} \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ 1\\\\ \\vdots\\\\ 1\\\\ \\end{bmatrix}}_{\\texttt{gamma.x.0}} + \\gamma_{x,z2}\\underbrace{\\begin{bmatrix} \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ -0.05\\\\ \\vdots\\\\ -0.72\\\\ \\end{bmatrix}}_{\\texttt{gamma.x.z2}} + \\gamma_{x}\\underbrace{\\begin{bmatrix} \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ \\texttt{NA}\\\\ \\vdots\\\\ \\texttt{NA}\\\\ 1\\\\ \\vdots\\\\ 1000\\\\ \\end{bmatrix}}_{\\texttt{gamma.x}}\\]","code":"inlamemi_model <- fit_inlamemi(data = simple_data,                            formula_moi = f_moi,                            formula_imp = f_imp,                            family_moi = \"gaussian\",                            error_type = c(\"berkson\", \"classical\"),                            prior.prec.moi = c(0.5, 0.5),                            prior.prec.berkson = c(10, 9),                            prior.prec.classical = c(10, 9),                            prior.prec.imp = c(0.5, 0.5),                            initial.prec.moi = 1,                            initial.prec.berkson = 1,                            initial.prec.classical = 1,                            initial.prec.imp = 1)  cat(show_data_structure(inlamemi_model$stack_data)$matrix_string) mis_mod <- fit_inlamemi(formula_moi = y ~ x + z1 + z2,                           formula_imp = x ~ z1,                           formula_mis = m ~ z2 + x,                           family_moi = \"gaussian\",                           data = mar_data,                           error_type = \"missing\",                           prior.beta.error = c(0, 1/1000),                           prior.gamma.error = c(0, 1/1000),                           prior.prec.moi = c(10, 9),                           prior.prec.imp = c(10, 9),                           initial.prec.moi = 1,                           initial.prec.imp = 1) cat(show_data_structure(mis_mod$stack_data)$matrix_string)"},{"path":"https://emmaskarstein.github.io/inlamemi/articles/how_to_not_use_inlamemi.html","id":"a-short-explanation-of-inla-stack-for-hierarchical-modelling","dir":"Articles","previous_headings":"","what":"A short explanation of inla.stack() for hierarchical modelling","title":"How to not use inlamemi","text":"inla.stack() function commonly used spatial modelling stochastic partial differential equations (SPDE), since data bit complex structure. description using stacks context can found chapter 7.3.3 Bayesian inference INLA. However, can also quite useful defining hierarchical models multiple likelihoods, traditionally need defined setting matrices structure matrices encode structure model, explained chapter 6.4 Bayesian inference INLA. stacks eventually converted matrices INLA, modeller may convenient define model stacks. one reason setting matrices need know beginning many levels model, since determines number columns matrices. However, stacks, model level stack, previous stacks change add additional stacks. , definition stacks model level can done independently. inla.stack function takes four arguments: data: list data left side formula (response) : list projector matrices, case non-spatial models just set list(1) effects: list SPDE index covariates, case, just list list containing covariates random effects. tag: character vector labelling group, can useful extracting certain parts stack later.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/articles/how_to_not_use_inlamemi.html","id":"classical-and-berkson-measurement-error-and-missingness","dir":"Articles","previous_headings":"","what":"Classical and Berkson measurement error and missingness","title":"How to not use inlamemi","text":"first example, use dataset simple_data, generated vignette Simulated examples. dataset classical Berkson measurement error, missing data, main model want fit \\[   y_i = \\beta_0 + \\beta_x x_i + \\beta_z z_i + \\varepsilon_i, \\] Berkson measurement error \\[   0 = -x_{true, } + r_i + u_{b,}, \\] classical measurement error model \\[   x_i = r_i + u_{c,}, \\] imputation model \\[   0 = -r_i + \\alpha_0 + \\alpha_z z_i + \\varepsilon_{r,}. \\] begin loading data defining number observations. Next, define priors initial values. inlamemi, fit model like : instead want without inlamemi, start defining stacks model level. main regression model, model \\[   y_i = \\beta_0 + \\beta_x x_i + \\beta_z z_i + \\varepsilon_i, \\] defined stack like : Next, Berkson measurement error model \\[   0 = -x_{true, } + r_i + u_{b,}, \\] corresponding stack : classical measurement error model \\[   x_i = r_i + u_{c,}, \\] stack : Finally, imputation model \\[   0 = -r_i + \\alpha_0 + \\alpha_z z_i + \\varepsilon_{r,}. \\] corresponding stack stack together, give us matrix formulation also specified manually. model, two latent effects, x r, specified formula. details formula, see supplementary material Skarstein et al (2023), can found online : https://emmaskarstein.github.io/Missing-data--measurement-error/simulation_example.html Finally, call inla() function. model consists four Gaussian sub-models, control.family argument give priors .","code":"data <- simple_data n <- nrow(data) # Prior for beta.x prior.beta <- c(0, 1/1000) # N(0, 10^3)  # Priors for y, measurement error and true x-value precision prior.prec.y <- c(10, 9) prior.prec.u_b <- c(10, 9) prior.prec.u_c <- c(10, 9) prior.prec.r <- c(10, 9)  # Initial values initial.prec.y <- 1 initial.prec.u_b <- 1 initial.prec.u_c <- 1 initial.prec.r <- 1 # Fit the model simple_model <- fit_inlamemi(data = data,                            formula_moi = y ~ x + z,                            formula_imp = x ~ z,                            family_moi = \"gaussian\",                            error_type = c(\"berkson\", \"classical\"),                            prior.prec.moi = prior.prec.y,                            prior.prec.berkson = prior.prec.u_b,                            prior.prec.classical = prior.prec.u_c,                            prior.prec.imp = prior.prec.r,                            initial.prec.moi = initial.prec.y,                            initial.prec.berkson = initial.prec.u_b,                            initial.prec.classical = initial.prec.u_c,                            initial.prec.imp = initial.prec.r) stk_moi <- inla.stack(data = list(y_moi = data$y),                       A = list(1),                       effects = list(                         list(beta.0 = rep(1, n),                              beta.x = 1:n,                              beta.z = data$z)),                       tag = \"moi\") stk_b <- inla.stack(data = list(y_berkson = rep(0, n)),                     A = list(1),                     effects = list(                       list(id.x = 1:n,                            weight.x = -1,                            id.r = 1:n,                            weight.r = 1)),                     tag = \"berkson\") stk_c <- inla.stack(data = list(y_classical = data$x),                     A = list(1),                     effects = list(                       list(id.r = 1:n,                            weight.r = 1)),                     tag = \"classical\") stk_imp <- inla.stack(data = list(y_imp = rep(0, n)),                       A = list(1),                       effects = list(                         list(id.r = 1:n,                              weight.r = rep(-1, n),                              alpha.0 = rep(1, n),                              alpha.z = data$z)),                       tag = \"imputation\") stk_full <- inla.stack(stk_moi, stk_b, stk_c, stk_imp) formula <- list(y_moi, y_berkson, y_classical, y_imp) ~ - 1 + beta.0 + beta.z +   f(beta.x, copy = \"id.x\",     hyper = list(beta = list(param = c(0, 1/1000), fixed = FALSE))) +   f(id.x, weight.x, model = \"iid\", values = 1:n,     hyper = list(prec = list(initial = -15, fixed = TRUE))) +   f(id.r, weight.r, model=\"iid\", values = 1:n,     hyper = list(prec = list(initial = -15, fixed = TRUE))) +   alpha.0 + alpha.z model_sim <- inla(formula, data = inla.stack.data(stk_full),                   family = c(\"gaussian\", \"gaussian\", \"gaussian\", \"gaussian\"),                   control.family = list(                     list(hyper = list(prec = list(initial = log(initial.prec.y),                                                   param = prior.prec.y,                                                   fixed = FALSE))),                     list(hyper = list(prec = list(initial = log(initial.prec.u_b),                                                   param = prior.prec.u_b,                                                   fixed = FALSE))),                     list(hyper = list(prec = list(initial = log(initial.prec.u_c),                                                   param = prior.prec.u_c,                                                   fixed = FALSE))),                     list(hyper = list(prec = list(initial = log(initial.prec.r),                                                   param = prior.prec.r,                                                   fixed = FALSE)))                   ),                   control.predictor = list(compute = TRUE) )  summary(model_sim) #> Time used: #>     Pre = 0.322, Running = 1.48, Post = 0.127, Total = 1.93  #> Fixed effects: #>          mean    sd 0.025quant 0.5quant 0.975quant  mode kld #> beta.0  1.030 0.218      0.612    1.029      1.440 1.025   0 #> beta.z  1.912 0.387      1.226    1.903      2.566 1.911   0 #> alpha.0 1.033 0.051      0.934    1.033      1.132 1.033   0 #> alpha.z 2.025 0.052      1.922    2.025      2.127 2.025   0 #>  #> Random effects: #>   Name     Model #>     id.x IID model #>    id.r IID model #>    beta.x Copy #>  #> Model hyperparameters: #>                                             mean    sd 0.025quant 0.5quant #> Precision for the Gaussian observations    1.126 0.354      0.571    1.080 #> Precision for the Gaussian observations[2] 1.125 0.343      0.594    1.077 #> Precision for the Gaussian observations[3] 0.925 0.108      0.731    0.919 #> Precision for the Gaussian observations[4] 0.979 0.125      0.754    0.971 #> Beta for beta.x                            1.973 0.201      1.574    1.975 #>                                            0.975quant  mode #> Precision for the Gaussian observations          1.95 0.994 #> Precision for the Gaussian observations[2]       1.93 0.989 #> Precision for the Gaussian observations[3]       1.16 0.905 #> Precision for the Gaussian observations[4]       1.25 0.958 #> Beta for beta.x                                  2.37 1.980 #>  #> Marginal log-Likelihood:  -20700.02  #>  is computed  #> Posterior summaries for the linear predictor and the fitted values are computed #> (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')"},{"path":"https://emmaskarstein.github.io/inlamemi/articles/how_to_not_use_inlamemi.html","id":"a-model-for-missing-data-missing-not-at-random","dir":"Articles","previous_headings":"","what":"A model for missing data, missing not at random","title":"How to not use inlamemi","text":"example, dealing missing data, show include another level model potentially capture missingness mechanism may depend available covariates. dataset, simulated , let value covariate x missingness depend another covariate z1 (corresponding imputation model), probability entry x missing depends another covariate z2 (corresponding missingness model). main model interest case \\[ y_i = \\beta_0 + \\beta_x x_{true,} + \\beta_{z_1} z_{1,} + \\beta_{z_2} z_{2,} + \\varepsilon_i , \\] stack : classical measurement error just functioning link case, model \\[   x_{obs, } = x_{true, } + u_{c,}, \\] precision \\(u_{c,}\\) set high \\(\\) \\(x_{obs,}\\) observed. stack level : Next imputation model \\[   0 = -x_{true,} + \\alpha_0 + \\alpha_{z_1} z_{1,} + \\varepsilon_{x,}, \\] stack missingness model binomial model describing probability missing, \\(p_m\\), may depend covariates. model \\[   \\text{logit}(p_{m,}) = \\gamma_0 + \\gamma_x x_{true,} + \\gamma_{z_2} z_{2,}, \\] stack : join stacks together: defining formula, now need define hyperparameter gamma.x, way define beta.x. scaled copy id.x. Since don’t measurement error case, set precision high classical error model argument scale. Looking summary, importantly, note model picks gamma.0 gamma.z2, defined -1.5 -0.5, respectively. data simulation, construct missingness x depend value x, correspond “missing random” mechanism. fact missingness x depends observed covariates indicates “missing random” mechanism (simulated ). missingness x depend covariates, “missing completely random”.","code":"set.seed(2024) n <- 1000  z1 <- rnorm(n, mean = 0, sd = 1) z2 <- rnorm(n, mean = 0, sd = 1)  alpha.0 <- 1; alpha.z1 <- 0.3 x <- rnorm(n, mean = alpha.0 + alpha.z1*z1, sd = 1)  gamma.0 <- -1.5; gamma.z2 <- -0.5 m_pred <- gamma.0 + gamma.z2*z2 m_prob <- exp(m_pred)/(1 + exp(m_pred)) m <- as.logical(rbinom(n, 1, prob = m_prob)) x_obs <- x x_obs[m] <- NA  sum(is.na(x_obs))/length(x_obs) #> [1] 0.183 beta.0 <- 1; beta.x <- 2; beta.z1 <- 2; beta.z2 <- 2 y <- beta.0 + beta.x*x + beta.z1*z1 + beta.z2*z2 + rnorm(n)  missing_data <- data.frame(y = y, x = x_obs, x_true = x, z1 = z1, z2 = z2) stk_moi <- inla.stack(data = list(y_moi = missing_data$y),                       A = list(1),                       effects = list(                         list(beta.0 = rep(1, n),                              beta.x = 1:n,                              beta.z1 = missing_data$z1,                              beta.z2 = missing_data$z2)),                       tag = \"moi\") stk_c <- inla.stack(data = list(y_classical = missing_data$x),                     A = list(1),                     effects = list(                       list(id.x = 1:n,                            weight.x = 1)),                     tag = \"classical\") stk_imp <- inla.stack(data = list(y_imp = rep(0, n)),                       A = list(1),                       effects = list(                         list(id.x = 1:n,                              weight.x = -1,                              alpha.0 = rep(1, n),                              alpha.z1 = missing_data$z1)),                       tag = \"imputation\") stk_mis <- inla.stack(data = list(y_mis = as.numeric(is.na(missing_data$x))),                       A = list(1),                       effects = list(                         list(gamma.x = 1:n,                              gamma.0 = rep(1, n),                              gamma.z2 = missing_data$z2)),                       tag = \"missingness\") stk_full <- inla.stack(stk_moi, stk_c, stk_imp, stk_mis) formula <- list(y_moi, y_classical, y_imp, y_mis) ~ - 1 +   beta.0 + beta.z1 + beta.z2 +   f(beta.x, copy = \"id.x\",     hyper = list(beta = list(param = c(0, 1/1000), fixed = FALSE))) +   f(id.x, weight.x, model = \"iid\", values = 1:n,     hyper = list(prec = list(initial = -15, fixed = TRUE))) +   f(gamma.x, copy = \"id.x\",     hyper = list(beta = list(param = c(0, 1/1000), fixed = FALSE))) +   alpha.0 + alpha.z1 + gamma.0 + gamma.z2 model_mnar <- inla(formula, data = inla.stack.data(stk_full),                   family = c(\"gaussian\", \"gaussian\", \"gaussian\", \"binomial\"),                   scale = c(rep(1, n), rep(10^8, n), rep(1, n), rep(1, n)),                   control.family = list(                     list(hyper = list(prec = list(initial = log(1),                                                   param = c(10, 9),                                                   fixed = FALSE))),                     list(hyper = list(prec = list(initial = log(1),                                                   param = c(10, 9),                                                   fixed = FALSE))),                     list(hyper = list(prec = list(initial = log(1),                                                   param = c(10, 9),                                                   fixed = FALSE))),                     list()),                   control.predictor = list(compute = TRUE, link = 1) )  summary(model_mnar) #> Time used: #>     Pre = 0.277, Running = 1.88, Post = 0.143, Total = 2.3  #> Fixed effects: #>            mean    sd 0.025quant 0.5quant 0.975quant   mode kld #> beta.0    1.039 0.050      0.941    1.039      1.138  1.040   0 #> beta.z1   2.004 0.036      1.933    2.004      2.076  2.004   0 #> beta.z2   1.985 0.036      1.914    1.985      2.057  1.985   0 #> alpha.0   1.010 0.032      0.947    1.010      1.074  1.010   0 #> alpha.z1  0.292 0.033      0.228    0.292      0.355  0.292   0 #> gamma.0  -1.508 0.123     -1.755   -1.507     -1.272 -1.507   0 #> gamma.z2 -0.425 0.088     -0.598   -0.425     -0.252 -0.425   0 #>  #> Random effects: #>   Name     Model #>     id.x IID model #>    beta.x Copy #>    gamma.x Copy #>  #> Model hyperparameters: #>                                              mean    sd 0.025quant 0.5quant #> Precision for the Gaussian observations     0.983 0.048      0.891    0.982 #> Precision for the Gaussian observations[2]  1.141 0.393      0.579    1.072 #> Precision for the Gaussian observations[3]  1.024 0.048      0.934    1.022 #> Beta for beta.x                             1.953 0.035      1.885    1.953 #> Beta for gamma.x                           -0.036 0.090     -0.211   -0.036 #>                                            0.975quant   mode #> Precision for the Gaussian observations         1.081  0.981 #> Precision for the Gaussian observations[2]      2.107  0.943 #> Precision for the Gaussian observations[3]      1.122  1.018 #> Beta for beta.x                                 2.021  1.953 #> Beta for gamma.x                                0.142 -0.037 #>  #> Marginal log-Likelihood:  -11663.14  #>  is computed  #> Posterior summaries for the linear predictor and the fitted values are computed #> (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')"},{"path":"https://emmaskarstein.github.io/inlamemi/articles/simulated_examples.html","id":"simple-example-with-missingness-and-two-types-of-measurement-error","dir":"Articles","previous_headings":"","what":"Simple example with missingness and two types of measurement error","title":"Simulated examples","text":"simple simulation Berkson classical error well missing data, check package works expected scenario.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/articles/simulated_examples.html","id":"generating-the-data","dir":"Articles","previous_headings":"Simple example with missingness and two types of measurement error","what":"Generating the data","title":"Simulated examples","text":"","code":"set.seed(2024) n <- 1000  # Covariate without error: z <- rnorm(n, mean = 0, sd = 1)  # Berkson error: u_b <- rnorm(n, sd = 1) alpha.0 <- 1; alpha.z <- 2 r <- rnorm(n, mean = alpha.0 + alpha.z*z, sd = 1) x <- r + u_b # Turn off Berkson by commenting out \"+ u_b\"  # Response: beta.0 <- 1; beta.x <- 2; beta.z <- 2 y <- beta.0 + beta.x*x + beta.z*z + rnorm(n)  # Classical error: u_c <- rnorm(n, sd = 1) x_obs <- r + u_c   # Missingness: m_pred <- -1.5 - 0.5*z # This gives a mean probability of missing of ca 0.2. m_prob <- exp(m_pred)/(1 + exp(m_pred))  m_index <- as.logical(rbinom(n, 1, prob = m_prob)) # MAR # m_index <- sample(1:n, 0.2*n, replace = FALSE) # MCAR x_obs[m_index] <- NA  simple_data <- data.frame(y = y, x = x_obs, z = z)"},{"path":"https://emmaskarstein.github.io/inlamemi/articles/simulated_examples.html","id":"fitting-the-model","dir":"Articles","previous_headings":"Simple example with missingness and two types of measurement error","what":"Fitting the model","title":"Simulated examples","text":"","code":"# Fit the model simple_model <- fit_inlamemi(data = simple_data,                           formula_moi = y ~ x + z,                           formula_imp = x ~ z,                           family_moi = \"gaussian\",                          error_type = c(\"berkson\", \"classical\"),                          prior.prec.moi = c(10, 9),       # Gamma(10, 9)                          prior.prec.berkson = c(10, 9),   # Gamma(10, 9)                          prior.prec.classical = c(10, 9), # Gamma(10, 9)                          prior.prec.imp = c(10, 9),       # Gamma(10, 9)                          prior.beta.error = c(0, 1/1000), # N(0, 10^3)                          initial.prec.moi = 1,                          initial.prec.berkson = 1,                          initial.prec.classical = 1,                          initial.prec.imp = 1) summary(simple_model) #> Formula for model of interest:  #> y ~ x + z #>  #> Formula for imputation model:  #> x ~ z #>  #> Error types:  #> [1] \"berkson\"   \"classical\" #>  #> Fixed effects for model of interest:  #>            mean        sd 0.025quant 0.5quant 0.975quant     mode #> beta.0 1.029268 0.2189274  0.6076093 1.027453   1.441695 1.021858 #> beta.z 1.909519 0.3881414  1.2101560 1.896968   2.567986 1.906304 #>  #> Coefficient for variable with measurement error and/or missingness:  #>            mean        sd 0.025quant 0.5quant 0.975quant     mode #> beta.x 1.973797 0.1978149   1.578932 1.975641   2.357788 1.983439 #>  #> Fixed effects for imputation model:  #>               mean         sd 0.025quant 0.5quant 0.975quant     mode #> alpha.x.0 1.033073 0.05061417  0.9337773 1.033081   1.132324 1.033081 #> alpha.x.z 2.024722 0.05227703  1.9222377 2.024705   2.127307 2.024705 #>  #> Model hyperparameters (apart from beta.x):  #>                                      mean        sd 0.025quant  0.5quant #> Precision for model of interest 1.1289950 0.3622903  0.5583926 1.0818648 #> Precision for x berkson model   1.1225886 0.3363409  0.5976573 1.0773224 #> Precision for x classical model 0.9248803 0.1070665  0.7338820 0.9181262 #> Precision for x imp model       0.9773889 0.1235176  0.7556484 0.9700847 #>                                 0.975quant      mode #> Precision for model of interest   1.968386 0.9962131 #> Precision for x berkson model     1.909106 0.9932454 #> Precision for x classical model   1.154877 0.9035709 #> Precision for x imp model         1.241149 0.9564159 simple.truth <- tibble::tribble(   ~\"variable\", ~\"value\",   \"beta.x\",  beta.x,    \"beta.z\",  beta.z,  #  \"beta.0\",  beta.0,    \"alpha.x.z\", alpha.z,   # \"alpha.0\", alpha.0   )  plot(simple_model, plot_intercepts = FALSE) +     geom_point(data = simple.truth, aes(x = value))"},{"path":"https://emmaskarstein.github.io/inlamemi/articles/simulated_examples.html","id":"missing-data-only","dir":"Articles","previous_headings":"","what":"Missing data only","title":"Simulated examples","text":"example, missingness one covariate, measurement error, shows simple imputation missing covariate R-INLA.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/articles/simulated_examples.html","id":"generating-the-data-1","dir":"Articles","previous_headings":"Missing data only","what":"Generating the data","title":"Simulated examples","text":"","code":"set.seed(2024) n <- 1000  # Covariate without missingness: z <- rnorm(n, mean = 0, sd = 1)  # Covariate that will have missingness: alpha.0 <- 1; alpha.z <- 2 x <- rnorm(n, mean = alpha.0 + alpha.z*z, sd = 1)  # Response: beta.0 <- 1; beta.x <- 2; beta.z <- 2 y <- beta.0 + beta.x*x + beta.z*z + rnorm(n)  # Missingness: m_pred <- -1.5 - 0.5*z # This gives a mean probability of missing of ca 0.2. m_prob <- exp(m_pred)/(1 + exp(m_pred))  m_index <- as.logical(rbinom(n, 1, prob = m_prob)) # MAR # m_index <- sample(1:n, 0.2*n, replace = FALSE) # MCAR x_obs <- x x_obs[m_index] <- NA  missing_data <- data.frame(y = y, x = x_obs, z = z)"},{"path":"https://emmaskarstein.github.io/inlamemi/articles/simulated_examples.html","id":"model-without-imputation","dir":"Articles","previous_headings":"Missing data only","what":"Model without imputation","title":"Simulated examples","text":"","code":"naive_model <- inla(formula = y ~ x + z, family = \"gaussian\", data = missing_data)  naive_model$summary.fixed #>                 mean         sd 0.025quant 0.5quant 0.975quant     mode #> (Intercept) 2.059952 0.07313492  1.9165113 2.059952   2.203392 2.059952 #> x           1.060038 0.04847764  0.9649586 1.060038   1.155118 1.060038 #> z           4.242952 0.09766027  4.0514099 4.242952   4.434494 4.242952 #>                      kld #> (Intercept) 1.017087e-11 #> x           1.020428e-11 #> z           1.015061e-11 naive_model$summary.hyperpar #>                                              mean         sd 0.025quant #> Precision for the Gaussian observations 0.3082829 0.01379352  0.2818484 #>                                         0.5quant 0.975quant      mode #> Precision for the Gaussian observations 0.308078  0.3359021 0.3076677"},{"path":"https://emmaskarstein.github.io/inlamemi/articles/simulated_examples.html","id":"model-with-imputation","dir":"Articles","previous_headings":"Missing data only","what":"Model with imputation","title":"Simulated examples","text":"","code":"missing_model <- fit_inlamemi(formula_moi = y ~ x + z,                             formula_imp = x ~ z,                             family_moi = \"gaussian\",                             data = missing_data,                              error_type = \"missing\",                              prior.prec.moi = c(2, 1),                             prior.prec.imp = c(2, 1),                             prior.beta.error = c(0, 1/1000),                             initial.prec.moi = 1,                             initial.prec.imp = 1)  summary(missing_model) #> Formula for model of interest:  #> y ~ x + z #>  #> Formula for imputation model:  #> x ~ z #>  #> Error types:  #> [1] \"missing\" #>  #> Fixed effects for model of interest:  #>             mean         sd 0.025quant  0.5quant 0.975quant     mode #> beta.0 0.9748062 0.04851084  0.8804373 0.9749302   1.068804 0.975037 #> beta.z 1.9457863 0.07624452  1.8001046 1.9464215   2.090634 1.946853 #>  #> Coefficient for variable with measurement error and/or missingness:  #>            mean         sd 0.025quant 0.5quant 0.975quant     mode #> beta.x 2.024533 0.03442626   1.957187 2.024387   2.092736 2.023775 #>  #> Fixed effects for imputation model:  #>               mean         sd 0.025quant 0.5quant 0.975quant     mode #> alpha.x.0 1.031099 0.03139300  0.9695367 1.031096   1.092680 1.031096 #> alpha.x.z 1.983402 0.03209519  1.9204512 1.983402   2.046349 1.983402 #>  #> Model hyperparameters (apart from beta.x):  #>                                     mean         sd 0.025quant 0.5quant #> Precision for model of interest 1.055434 0.05242200  0.9561771 1.054072 #> Precision for x classical model 1.137558 0.35775533  0.6229203 1.076416 #> Precision for x imp model       1.066595 0.04994561  0.9728900 1.065005 #>                                 0.975quant      mode #> Precision for model of interest   1.162530 1.0512286 #> Precision for x classical model   2.013859 0.9560475 #> Precision for x imp model         1.169505 1.0609195 missing_truth <- tibble::tribble(   ~\"variable\", ~\"value\",   \"beta.0\", beta.0,   \"beta.x\",  beta.x,    \"beta.z\",  beta.z,   \"alpha.x.0\", alpha.0,   \"alpha.x.z\", alpha.z )  plot(missing_model) +     geom_point(data = missing_truth, aes(x = value))"},{"path":"https://emmaskarstein.github.io/inlamemi/articles/simulated_examples.html","id":"random-effect-in-the-main-model","dir":"Articles","previous_headings":"","what":"Random effect in the main model","title":"Simulated examples","text":"example, simulate data grouped way modelled random effect model interest.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/articles/simulated_examples.html","id":"generating-the-data-2","dir":"Articles","previous_headings":"Random effect in the main model","what":"Generating the data","title":"Simulated examples","text":"","code":"m <- 10 # number of groups n <- 100 # number of observations per group N <- m*n # total number of observations  sd_y <- 3 # sd for the noise sd_w <- 2 # sd for random effect sd_x <- 2 # sd for covariate without error sd_u <- 1 # sd for measurement error  # Covariate without error z <- rnorm(N, 0, 2)  # Covariate with error x <- rnorm(N, 0, sd_x) # Independent of z, but can change that here x_obs <- x + rnorm(N, 0, sd_u)  # Random effect w_per_group <- rnorm(m, 0, sd_w) w <- rep(w_per_group, each = n)  # Response y <- 1 + 2*x + 2*z + w + rnorm(N, 0, sd_y)  reff_data <- data.frame(y = y, id = rep(1:m, each = n), x = x_obs, z = z)"},{"path":"https://emmaskarstein.github.io/inlamemi/articles/simulated_examples.html","id":"fitting-the-model-1","dir":"Articles","previous_headings":"Random effect in the main model","what":"Fitting the model","title":"Simulated examples","text":"Firstly, ignored measurement error, might fit model like :","code":"naive_model <- inla(y ~ x + z + f(id, model = \"iid\"),                     data = reff_data,                     family = \"gaussian\") summary(naive_model) #> Time used: #>     Pre = 0.216, Running = 0.2, Post = 0.0174, Total = 0.434  #> Fixed effects: #>               mean    sd 0.025quant 0.5quant 0.975quant   mode kld #> (Intercept) -0.316 0.560     -1.429   -0.316      0.796 -0.316   0 #> x            1.682 0.051      1.582    1.682      1.782  1.682   0 #> z            2.022 0.058      1.908    2.022      2.136  2.022   0 #>  #> Random effects: #>   Name     Model #>     id IID model #>  #> Model hyperparameters: #>                                          mean    sd 0.025quant 0.5quant #> Precision for the Gaussian observations 0.077 0.003      0.070    0.077 #> Precision for id                        0.401 0.184      0.145    0.367 #>                                         0.975quant  mode #> Precision for the Gaussian observations      0.084 0.077 #> Precision for id                             0.852 0.305 #>  #> Marginal log-Likelihood:  -2756.06  #>  is computed  #> Posterior summaries for the linear predictor and the fitted values are computed #> (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') # curve(dgamma(x, shape = 1.5, rate = 2), to = 2)  reff_model <- fit_inlamemi(formula_moi = y ~ x + z +                           f(id, model = \"iid\", hyper = list(prec = list(initial = -15, param = c(2, 2)))),                        formula_imp = x ~ 1,                        family_moi = \"gaussian\",                        error_type = \"classical\",                        data = reff_data,                        initial.prec.moi = 1/4,                         initial.prec.classical = 1,                         initial.prec.imp = 1/4,                        prior.prec.moi = c(1, 4),                        prior.prec.classical = c(10, 10),                        prior.prec.imp = c(1, 4),                        prior.beta.error = c(0, 1/1000))  summary(reff_model) #> Formula for model of interest:  #> y ~ x + z + f(id, model = \"iid\", hyper = list(prec = list(initial = -15,  #>     param = c(2, 2)))) #>  #> Formula for imputation model:  #> x ~ 1 #>  #> Error types:  #> [1] \"classical\" #>  #> Fixed effects for model of interest:  #>              mean         sd 0.025quant   0.5quant 0.975quant       mode #> beta.0 -0.3635868 0.54819427  -1.456017 -0.3634845  0.7279829 -0.3635302 #> beta.z  2.0221562 0.05813317   1.908135  2.0221573  2.1361715  2.0221572 #>  #> Coefficient for variable with measurement error and/or missingness:  #>            mean        sd 0.025quant 0.5quant 0.975quant     mode #> beta.x 2.127469 0.1828174   1.778318 2.123906   2.497901 2.108361 #>  #> Fixed effects for imputation model:  #>                mean         sd  0.025quant  0.5quant 0.975quant      mode #> alpha.x.0 0.1022765 0.07126938 -0.03750561 0.1022765  0.2420586 0.1022765 #>  #> Model hyperparameters (apart from beta.x):  #>                                      mean         sd 0.025quant  0.5quant #> Precision for model of interest 0.1096096 0.01857084 0.07859594 0.1077456 #> Precision for x classical model 0.9958466 0.32053863 0.49436153 0.9531186 #> Precision for x imp model       0.2513046 0.02471327 0.20724031 0.2497422 #> Precision for id                0.4173237 0.17459920 0.17003283 0.3863159 #>                                 0.975quant      mode #> Precision for model of interest  0.1514874 0.1035659 #> Precision for x classical model  1.7419707 0.8750733 #> Precision for x imp model        0.3044487 0.2459125 #> Precision for id                 0.8444264 0.3301460 reff.truth <- tibble::tribble(   ~\"variable\", ~\"value\",   \"beta.x\",  2,    \"beta.z\",  2,    \"beta.0\",  1,    \"alpha.x.0\", 0 )  plot(reff_model) +     geom_point(data = reff.truth, aes(x = value))"},{"path":"https://emmaskarstein.github.io/inlamemi/articles/simulated_examples.html","id":"interaction-effect-with-error-variable","dir":"Articles","previous_headings":"","what":"Interaction effect with error variable","title":"Simulated examples","text":"Interaction effects error prone variable (assumed) error-free variable can also used. syntax normal, interaction effect variables x s specified formula model interest x:s.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/articles/simulated_examples.html","id":"generating-the-data-3","dir":"Articles","previous_headings":"Interaction effect with error variable","what":"Generating the data","title":"Simulated examples","text":"","code":"set.seed(2024) n <- 1000  # Covariate without error: s <- c(rep(0, n/2), rep(1, n/2))  # Classical error: x <- rnorm(n, mean = 0, sd = 2) u_c <- rnorm(n, sd = 1) x_obs <- x + u_c   # Response: beta.0 <- 1; beta.x.s <- 2 y <- beta.0 + beta.x*x + beta.x.s*x_obs*s + rnorm(n)  interact_data <- data.frame(y = y, x = x_obs, z = z, s = s)"},{"path":"https://emmaskarstein.github.io/inlamemi/articles/simulated_examples.html","id":"fitting-the-model-2","dir":"Articles","previous_headings":"Interaction effect with error variable","what":"Fitting the model","title":"Simulated examples","text":"","code":"interact_model <- fit_inlamemi(formula_moi = y ~ x:s,                              formula_imp = x ~ 1,                              family_moi = \"gaussian\",                              data = interact_data,                              error_type = \"classical\",                              prior.beta.error = c(0, 0.01),                              prior.prec.moi = c(10, 9),                              prior.prec.classical = c(10, 9),                              prior.prec.imp = c(10, 8),                              initial.prec.moi = 1,                              initial.prec.classical = 1,                              initial.prec.imp = 2) summary(interact_model) #> Formula for model of interest:  #> y ~ x:s #>  #> Formula for imputation model:  #> x ~ 1 #>  #> Error types:  #> [1] \"classical\" #>  #> Fixed effects for model of interest:  #>               mean         sd 0.025quant   0.5quant 0.975quant        mode #> beta.0  1.00812511 0.07963113  0.8519223  1.0081282  1.1643106  1.00812830 #> beta.s -0.08603344 0.13380538 -0.3484830 -0.0860287  0.1763892 -0.08602869 #>  #> Coefficient for variable with measurement error and/or missingness:  #>             mean         sd 0.025quant 0.5quant 0.975quant     mode #> beta.sx 2.055698 0.06324609   1.931365 2.055636   2.180388 2.055381 #> beta.x  1.709303 0.04044708   1.629976 1.709200   1.789231 1.708772 #>  #> Fixed effects for imputation model:  #>                 mean         sd  0.025quant   0.5quant 0.975quant       mode #> alpha.x.0 0.03481148 0.06849287 -0.09952399 0.03481148   0.169147 0.03481148 #>  #> Model hyperparameters (apart from beta.sx, beta.x):  #>                                      mean         sd 0.025quant  0.5quant #> Precision for model of interest 0.4104124 0.03322378  0.3494813 0.4088762 #> Precision for x classical model 4.0976673 0.44068639  3.2875824 4.0779820 #> Precision for x imp model       0.2252345 0.01058275  0.2049523 0.2250435 #>                                 0.975quant      mode #> Precision for model of interest  0.4802120 0.4054147 #> Precision for x classical model  5.0204398 4.0465558 #> Precision for x imp model        0.2466095 0.2247854 plot(interact_model)"},{"path":"https://emmaskarstein.github.io/inlamemi/articles/simulated_examples.html","id":"logistic-regression-with-classical-error-and-missing-data","dir":"Articles","previous_headings":"","what":"Logistic regression with classical error and missing data","title":"Simulated examples","text":"show fit logistic regression model. Modeling error missing data:","code":"set.seed(1) nn <- 1000  z <- rbinom(nn, 1, 0.5) x <- rnorm(nn, 1-0.5*z, 1)  # Error w <- x + rnorm(nn, 0, 1)  # Generating missing data, depending on z eta <- -1 + z prob_missing <- exp(eta)/(1 + exp(eta)) missing_index <- rbinom(nn, 1, prob_missing)  # Proportion missing: sum(missing_index)/nn #> [1] 0.393 # Replace the values in w by missing in case the index for missingness is =1: w <- ifelse(missing_index==1, NA, w)  # Generate binomial response eta <- x + z  prob <- exp(eta)/(1 + exp(eta)) y <- rbinom(nn, 1, prob)  data_binom <- data.frame(x = x, z = z, y = y, w = w) model_binom <- fit_inlamemi(data = data_binom,                        formula_moi = y ~ w + z,                        formula_imp = w ~ z,                        formula_mis = m ~ z,                        family_moi = \"binomial\",                        error_type = c(\"classical\",\"missing\"),                        prior.prec.classical = c(10, 9),                        prior.prec.imp = c(10, 9),                        prior.beta.error = c(0, 1/1000),                        initial.prec.classical = 2,                        initial.prec.imp = 1)  summary(model_binom) plot(model_binom)"},{"path":"https://emmaskarstein.github.io/inlamemi/articles/simulated_examples.html","id":"poisson-regression-with-classical-error-and-missing-data","dir":"Articles","previous_headings":"","what":"Poisson regression with classical error and missing data","title":"Simulated examples","text":"show fit Poisson regression model, model interest random intercept term. Simple regression models correct error-prone variables check effect: Modeling error missing data:","code":"set.seed(1) nn <- 1000  z <- rbinom(nn, 1, 0.5) x <- rnorm(nn, 1-0.5*z, 1)  # Error w <- x + rnorm(nn, 0, 1)  # Generating missing data, depending on z eta <- -1 + z prob_missing <- exp(eta)/(1 + exp(eta)) missing_index <- rbinom(nn, 1, prob_missing)  # Proportion missing: sum(missing_index)/nn #> [1] 0.393 # Replace the values in w by missing in case the index for missingness is =1: w <- ifelse(missing_index==1, NA, w)  # Random effect to include in the regression model: re <- rep(rnorm(nn/20), each = 20)  # Linear predictor eta <-  x + z + re    # Generate Poisson response y <- rpois(nn, exp(eta))  data_pois <- data.frame(x = x, z = z, y = y, w = w, id = rep(seq(1:50), each = 20)) library(lme4) summary(glmer(y ~ x + z + (1|id), data = data_pois, family=\"poisson\"))$coef  summary(glmer(y ~ w + z + (1|id), data = data_pois, family=\"poisson\"))$coef model_pois <- fit_inlamemi(data = data_pois,                        formula_moi = y ~ w + z + f(id,model=\"iid\"),                        formula_imp = w ~ z,                        formula_mis = m ~ z,                        family_moi = \"poisson\",                        error_type = c(\"classical\",\"missing\"),                        prior.prec.classical = c(19, 9),                        prior.prec.imp = c(10, 9),                        prior.beta.error = c(0, 1/1000),                        initial.prec.classical = 2,                        initial.prec.imp = 1)  summary(model_pois) plot(model_pois)"},{"path":"https://emmaskarstein.github.io/inlamemi/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Emma Skarstein. Maintainer, author, copyright holder. Stefanie Muff. Author.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Skarstein ES, Muff S (2023). inlamemi: Missing data imputation measurment error adjustment INLA. R package version 0.1.0, https://github.com/emmaSkarstein/inlamemi.","code":"@Manual{,   title = {inlamemi: Missing data imputation and measurment error adjustment with INLA},   author = {E. S. Skarstein and S. Muff},   year = {2023},   note = {R package version 0.1.0},   url = {https://github.com/emmaSkarstein/inlamemi}, }"},{"path":"https://emmaskarstein.github.io/inlamemi/index.html","id":"inlamemi-","dir":"","previous_headings":"","what":"Missing Data and Measurement Error Modelling in INLA","title":"Missing Data and Measurement Error Modelling in INLA","text":"Fitting measurement error models missing data imputation models INLA trivial, requires several workarounds order fit model. time, Bayesian hierarchical framework attractive modeling types data, since hierarchical model structure allows us describe data collected, errors may , model specification. supplying informative priors, may able adjust biases due errors, propagate uncertainty cause. recently, complicated implement kinds models R-INLA. package provides helpful interface makes measurement error missing data modelling R-INLA much feasible.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Missing Data and Measurement Error Modelling in INLA","text":"can install development version inlamemi GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"emmaSkarstein/inlamemi\")"},{"path":"https://emmaskarstein.github.io/inlamemi/index.html","id":"when-should-i-use-this-package","dir":"","previous_headings":"","what":"When should I use this package?","title":"Missing Data and Measurement Error Modelling in INLA","text":"package designed fitting models one covariate classical measurement error, Berkson measurement error, missing observations, combination three. mean missing data, package can missing data imputation. model must class models possible fit R-INLA. means can used common regression types, like linear regression logistic regression, can include many error free covariates needed. can also include random effects, way normally include effects R-INLA. Interaction effects error prone variable also dealt package. even possible fit models cases multiple variables error missingness, though something one careful , models rely heavily priors give .","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/index.html","id":"overview-of-examples","dir":"","previous_headings":"","what":"Overview of examples","title":"Missing Data and Measurement Error Modelling in INLA","text":"Examples use package can found vignettes.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/index.html","id":"quick-guide-how-can-i-use-this-package","dir":"","previous_headings":"","what":"Quick guide: How can I use this package?","title":"Missing Data and Measurement Error Modelling in INLA","text":"dataset simple_data included package, simple simulated data set, used illustrate package. data set, response variable y, error free covariate z, covariate observed classical error, Berkson error missingness, called x. wish fit model y = β0 + βxx + βzz + ε , adjusting errors x. First load package: Next, need specify formula main model formula imputation model. done standard way R: imputation model, take advantage correlation x error free covariate z, imputation model x = α0 + αzz + εx . write adjusting measurement error, completely dependent information measurement error variances σuc2 (classical error) σub2 (Berkson error), since size variance affect estimates biased. can gain information variances different ways, repeated measurements made can put directly model estimate error variance, expert knowledge error size, can used specify informative prior variance (precision, since INLA precision used, rather variance). case, since fact simulated data , know error variances cases close 1, specify priors modes 1. fit_inlamemi function also need specify likelihood model interest, case Gaussian. fit model, can view summary: can use default plot function see plot fixed effects estimated coefficient variable error:","code":"library(inlamemi) main_formula <- y ~ x + z imputation_formula <- x ~ z simple_model <- fit_inlamemi(data = simple_data,                             formula_moi = main_formula,                             formula_imp = imputation_formula,                             family_moi = \"gaussian\",                            error_type = c(\"berkson\", \"classical\", \"missing\"),                            prior.prec.moi = c(10, 9),                            prior.prec.berkson = c(10, 9),                             prior.prec.classical = c(10, 9),                            prior.prec.imp = c(10, 9),                            prior.beta.error = c(0, 1/1000),                            initial.prec.moi = 1,                            initial.prec.berkson = 1,                            initial.prec.classical = 1,                            initial.prec.imp = 1) summary(simple_model) #> Formula for model of interest:  #> y ~ x + z #>  #> Formula for imputation model:  #> x ~ z #>  #> Error types:  #> [1] \"berkson\"   \"classical\" \"missing\"   #>  #> Fixed effects for model of interest:  #>            mean        sd 0.025quant 0.5quant 0.975quant     mode #> beta.0 1.027956 0.2185053  0.6085896 1.025854   1.434766 1.021004 #> beta.z 1.906813 0.3873275  1.2158176 1.894296   2.556740 1.904250 #>  #> Coefficient for variable with measurement error and/or missingness:  #>            mean        sd 0.025quant 0.5quant 0.975quant     mode #> beta.x 1.972649 0.2029525   1.566473 1.974896   2.365541 1.984445 #>  #> Fixed effects for imputation model:  #>               mean         sd 0.025quant 0.5quant 0.975quant     mode #> alpha.x.0 1.033078 0.05060148  0.9338064 1.033086   1.132303 1.033086 #> alpha.x.z 2.024712 0.05226422  1.9222529 2.024694   2.127272 2.024694 #>  #> Model hyperparameters (apart from beta.x):  #>                                      mean        sd 0.025quant  0.5quant #> Precision for model of interest 1.1299995 0.3666955  0.5611600 1.0796224 #> Precision for x berkson model   1.1269739 0.3461986  0.5882062 1.0799184 #> Precision for x classical model 0.9253109 0.1088522  0.7317659 0.9182306 #> Precision for x imp model       0.9779404 0.1256207  0.7521229 0.9706161 #>                                 0.975quant      mode #> Precision for model of interest   1.988328 0.9871190 #> Precision for x berkson model     1.937381 0.9928605 #> Precision for x classical model   1.159767 0.9028002 #> Precision for x imp model         1.245850 0.9573579 plot(simple_model)"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/extract_random_effects.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract random effects from formula — extract_random_effects","title":"Extract random effects from formula — extract_random_effects","text":"Extract random effects formula","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/extract_random_effects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract random effects from formula — extract_random_effects","text":"","code":"extract_random_effects(formula)"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/extract_random_effects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract random effects from formula — extract_random_effects","text":"formula object class \"formula\", either formula model interest, imputation model missingness model.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/extract_random_effects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract random effects from formula — extract_random_effects","text":"list containing \"reff_vars\", random effect variables, \"reff\", entire random effect term.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/extract_variables_from_formula.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract and group variables from formulas — extract_variables_from_formula","title":"Extract and group variables from formulas — extract_variables_from_formula","text":"Helper function takes formulas model interest imputation model, groups responses, covariates, covariate error covariate(s) without error, sub-models.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/extract_variables_from_formula.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract and group variables from formulas — extract_variables_from_formula","text":"","code":"extract_variables_from_formula(   formula_moi,   formula_imp,   formula_mis = NULL,   error_variable = NULL )"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/extract_variables_from_formula.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract and group variables from formulas — extract_variables_from_formula","text":"formula_moi object class \"formula\", describing main model fitted. formula_imp object class \"formula\", describing imputation model mismeasured /missing observations. formula_mis object class \"formula\", describing missingness model. need response variable, since always binary missingness indicator. error_variable character vector name(s) variable(s) error.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/extract_variables_from_formula.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract and group variables from formulas — extract_variables_from_formula","text":"list containing names different variables model. names elements list \"response_moi\" (response moi), \"covariates_moi\" (covariates moi), \"error_variable\" (name variable error missing data), \"covariates_error_free\" (moi covariates without error), \"response_imp\" (imputation model response), \"covariates_imp\" (imputation model covariates).","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/extract_variables_from_formula.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract and group variables from formulas — extract_variables_from_formula","text":"","code":"extract_variables_from_formula(formula_moi = y ~ x + z,                                formula_imp = x ~ z) #> $response_moi #> [1] \"y\" #>  #> $covariates_moi #> [1] \"x\" \"z\" #>  #> $random_effects_moi #> [1] \"\" #>  #> $random_effect_variables_moi #> [1] \"\" #>  #> $error_variable #> [1] \"x\" #>  #> $error_interaction_list #> [1] \"\" #>  #> $error_interaction_variables #> [1] \"\" #>  #> $covariates_error_free #> [1] \"z\" #>  #> $response_imp #> $response_imp[[1]] #> [1] \"x\" #>  #>  #> $covariates_imp #> $covariates_imp[[1]] #> [1] \"z\" #>  #>  #> $random_effects_imp #> $random_effects_imp[[1]] #> [1] \"\" #>  #>  #> $random_effect_variables_imp #> $random_effect_variables_imp[[1]] #> [1] \"\" #>  #>  #> $covariates_mis #> $covariates_mis[[1]] #> [1] \"\" #>  #>  #> $covariates_error_free_mis_list #> $covariates_error_free_mis_list[[1]] #> [1] \"\" #>  #>  #> $random_effects_mis #> $random_effects_mis[[1]] #> [1] \"\" #>  #>  #> $random_effect_variables_mis #> $random_effect_variables_mis[[1]] #> [1] \"\" #>  #>"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/fit_inlamemi.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit model for measurement error and missing data in INLA — fit_inlamemi","title":"Fit model for measurement error and missing data in INLA — fit_inlamemi","text":"wrapper function around \"INLA::inla()\", providing necessary structure fit hierarchical measurement error model adjusts coefficient estimates account biases due measurement error missing data.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/fit_inlamemi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit model for measurement error and missing data in INLA — fit_inlamemi","text":"","code":"fit_inlamemi(   formula_moi,   formula_imp = NULL,   formula_mis = NULL,   family_moi,   data,   error_type = \"classical\",   error_variable = NULL,   repeated_observations = FALSE,   classical_error_scaling = NULL,   prior.prec.moi = NULL,   prior.prec.berkson = NULL,   prior.prec.classical = NULL,   prior.prec.imp = NULL,   prior.beta.error = NULL,   prior.gamma.error = NULL,   initial.prec.moi = NULL,   initial.prec.berkson = NULL,   initial.prec.classical = NULL,   initial.prec.imp = NULL,   control.family.moi = NULL,   control.family.berkson = NULL,   control.family.classical = NULL,   control.family.imp = NULL,   control.family = NULL,   control.predictor = NULL,   ... )"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/fit_inlamemi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit model for measurement error and missing data in INLA — fit_inlamemi","text":"formula_moi object class \"formula\", describing main model fitted. formula_imp object class \"formula\", describing imputation model mismeasured /missing observations. formula_mis object class \"formula\", describing missingness model. need response variable, since always binary missingness indicator. family_moi string indicating likelihood family model interest (main model). data object class data.frame list containing variables model. error_type type error (one \"classical\", \"berkson\", \"missing\") error_variable character vector name(s) variable(s) error. repeated_observations variable measurement error /missingness repeated observations? , set \"TRUE\". case, specifying formula, use name variable without numbers, specifying data, make sure repeated measurements end number, .e \"sbp1\" \"sbp2\". classical_error_scaling can specified classical measurement error varies across observations. Must vector length data. prior.prec.moi string containing parameters prior precision residual term model interest. prior.prec.berkson string containing parameters prior precision error term Berkson error model. prior.prec.classical string containing parameters prior precision error term classical error model. prior.prec.imp string containing parameters precision latent variable x, variable described imputation model. prior.beta.error parameters prior coefficient error prone variable. TODO: distribution? Gamma? prior.gamma.error parameters prior coefficient variable missingness missingness model. TODO: distribution? Gamma? initial.prec.moi initial value precision residual term model interest. initial.prec.berkson initial value precision residual term Berkson error term. initial.prec.classical initial value precision residual term classical error term. initial.prec.imp initial value precision residual term latent variable r. control.family.moi control.family component model interest. Can specified using inla syntax instead passing \"prior.prec...\" \"initial.prec...\" arguments, cases hyperparameters needed model interest, see instance survival models. control.family.berkson control.family component Berkson model. Can specified using inla syntax instead passing \"prior.prec...\" \"initial.prec...\" arguments. Useful cases flexibility needed, instance one wants specify different prior distribution Gamma. control.family.classical control.family component classical model. Can specified using inla syntax instead passing \"prior.prec...\" \"initial.prec...\" arguments. Useful cases flexibility needed, instance one wants specify different prior distribution Gamma. control.family.imp control.family component imputation model. Can specified using inla syntax instead passing \"prior.prec...\" \"initial.prec...\" arguments. Useful cases flexibility needed, instance one wants specify different prior distribution Gamma. control.family control.family use inla (can provided directly instead passing \"prior.prec....\" \"initial.prec...\" arguments. specified, \"control.family...\" \"prior.prec...\" arguments provided ignored. control.predictor control.predictor use inla. ... arguments pass `inla`.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/fit_inlamemi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit model for measurement error and missing data in INLA — fit_inlamemi","text":"object class inlamemi.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/fit_inlamemi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit model for measurement error and missing data in INLA — fit_inlamemi","text":"","code":"# Fit the model simple_model <- fit_inlamemi(data = simple_data,                            formula_moi = y ~ x + z,                            formula_imp = x ~ z,                            family_moi = \"gaussian\",                            error_type = c(\"berkson\", \"classical\"),                            error_variable = \"x\",                            prior.prec.moi = c(10, 9),                            prior.prec.berkson = c(10, 9),                            prior.prec.classical = c(10, 9),                            prior.prec.imp = c(10, 9),                            prior.beta.error = c(0, 1/1000),                            initial.prec.moi = 1,                            initial.prec.berkson = 1,                            initial.prec.classical = 1,                            initial.prec.imp = 1)"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/framingham.html","id":null,"dir":"Reference","previous_headings":"","what":"Framingham heart study data — framingham","title":"Framingham heart study data — framingham","text":"data set observations heart disease status systolic blood pressure (SBP) smoking status.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/framingham.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Framingham heart study data — framingham","text":"","code":"framingham"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/framingham.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Framingham heart study data — framingham","text":"## `framingham` data frame 641 rows 4 columns: disease binary response, 1 heart disease, 0 otherwise sbp1 log(SBP − 50) examination 1 (centered) sbp2 log(SBP − 50) examination 2 (centered) smoking Smoking status, 1 smoking, 0 otherwise.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/framingham.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Framingham heart study data — framingham","text":"Carrol book?","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/inla_survival_families.html","id":null,"dir":"Reference","previous_headings":"","what":"List the survival likelihoods in INLA — inla_survival_families","title":"List the survival likelihoods in INLA — inla_survival_families","text":"List survival likelihoods INLA","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/inla_survival_families.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List the survival likelihoods in INLA — inla_survival_families","text":"","code":"inla_survival_families()"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/inla_survival_families.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List the survival likelihoods in INLA — inla_survival_families","text":"List survival models INLA","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/make_inlamemi_control.family.html","id":null,"dir":"Reference","previous_headings":"","what":"Make ","title":"Make ","text":"Make \"control.family\" argument passing \"inla\" function","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/make_inlamemi_control.family.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make ","text":"","code":"make_inlamemi_control.family(   formula_mis = NULL,   family_moi,   error_type = \"classical\",   prior.prec.moi = NULL,   prior.prec.berkson = NULL,   prior.prec.classical = NULL,   prior.prec.imp = NULL,   initial.prec.moi = NULL,   initial.prec.berkson = NULL,   initial.prec.classical = NULL,   initial.prec.imp = NULL,   control.family.moi = NULL,   control.family.berkson = NULL,   control.family.classical = NULL,   control.family.imp = NULL,   control.family = NULL )"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/make_inlamemi_control.family.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make ","text":"formula_mis object class \"formula\", describing missingness model. need response variable, since always binary missingness indicator. family_moi string indicating likelihood family model interest (main model). error_type type error (one \"classical\", \"berkson\", \"missing\") prior.prec.moi string containing parameters prior precision residual term model interest. prior.prec.berkson string containing parameters prior precision error term Berkson error model. prior.prec.classical string containing parameters prior precision error term classical error model. prior.prec.imp string containing parameters precision latent variable x, variable described imputation model. initial.prec.moi initial value precision residual term model interest. initial.prec.berkson initial value precision residual term Berkson error term. initial.prec.classical initial value precision residual term classical error term. initial.prec.imp initial value precision residual term latent variable r. control.family.moi control.family component model interest. Can specified using inla syntax instead passing \"prior.prec...\" \"initial.prec...\" arguments, cases hyperparameters needed model interest, see instance survival models. control.family.berkson control.family component Berkson model. Can specified using inla syntax instead passing \"prior.prec...\" \"initial.prec...\" arguments. Useful cases flexibility needed, instance one wants specify different prior distribution Gamma. control.family.classical control.family component classical model. Can specified using inla syntax instead passing \"prior.prec...\" \"initial.prec...\" arguments. Useful cases flexibility needed, instance one wants specify different prior distribution Gamma. control.family.imp control.family component imputation model. Can specified using inla syntax instead passing \"prior.prec...\" \"initial.prec...\" arguments. Useful cases flexibility needed, instance one wants specify different prior distribution Gamma. control.family control.family use inla (can provided directly instead passing \"prior.prec....\" \"initial.prec...\" arguments. specified, \"control.family...\" \"prior.prec...\" arguments provided ignored.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/make_inlamemi_control.family.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make ","text":"\"control.family\" argument passed inla, list \"control.family\" arguments model hierarchical measurement error model.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/make_inlamemi_control.family.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make ","text":"","code":"make_inlamemi_control.family(   family_moi = \"gaussian\",   error_type = c(\"berkson\", \"classical\"),   prior.prec.moi = c(10, 9),   prior.prec.berkson = c(10, 9),   prior.prec.classical = c(10, 9),   prior.prec.imp = c(10, 9),   initial.prec.moi = 1,   initial.prec.berkson = 1,   initial.prec.classical = 1,   initial.prec.imp = 1) #> [[1]] #> [[1]]$hyper #> [[1]]$hyper$prec #> [[1]]$hyper$prec$initial #> [1] 0 #>  #> [[1]]$hyper$prec$param #> [1] 10  9 #>  #> [[1]]$hyper$prec$fixed #> [1] FALSE #>  #>  #>  #>  #> [[2]] #> [[2]]$hyper #> [[2]]$hyper$prec #> [[2]]$hyper$prec$initial #> [1] 0 #>  #> [[2]]$hyper$prec$param #> [1] 10  9 #>  #> [[2]]$hyper$prec$fixed #> [1] FALSE #>  #>  #>  #>  #> [[3]] #> [[3]]$hyper #> [[3]]$hyper$prec #> [[3]]$hyper$prec$initial #> [1] 0 #>  #> [[3]]$hyper$prec$param #> [1] 10  9 #>  #> [[3]]$hyper$prec$fixed #> [1] FALSE #>  #>  #>  #>  #> [[4]] #> [[4]]$hyper #> [[4]]$hyper$prec #> [[4]]$hyper$prec$initial #> [1] 0 #>  #> [[4]]$hyper$prec$param #> [1] 10  9 #>  #> [[4]]$hyper$prec$fixed #> [1] FALSE #>  #>  #>  #>   make_inlamemi_control.family(   family_moi = \"weibull.surv\",   error_type = c(\"classical\", \"missing\"),   control.family.moi =     list(hyper = list(alpha = list(param = 0.01,                                    initial = log(1.4),                                    fixed = FALSE))),   prior.prec.classical = c(0.5, 0.5),   prior.prec.imp = c(0.5, 0.5),   initial.prec.classical = 2.8,   initial.prec.imp = 1) #> [[1]] #> [[1]]$hyper #> [[1]]$hyper$alpha #> [[1]]$hyper$alpha$param #> [1] 0.01 #>  #> [[1]]$hyper$alpha$initial #> [1] 0.3364722 #>  #> [[1]]$hyper$alpha$fixed #> [1] FALSE #>  #>  #>  #>  #> [[2]] #> [[2]]$hyper #> [[2]]$hyper$prec #> [[2]]$hyper$prec$initial #> [1] 1.029619 #>  #> [[2]]$hyper$prec$param #> [1] 0.5 0.5 #>  #> [[2]]$hyper$prec$fixed #> [1] FALSE #>  #>  #>  #>  #> [[3]] #> [[3]]$hyper #> [[3]]$hyper$prec #> [[3]]$hyper$prec$initial #> [1] 0 #>  #> [[3]]$hyper$prec$param #> [1] 0.5 0.5 #>  #> [[3]]$hyper$prec$fixed #> [1] FALSE #>  #>  #>  #>"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/make_inlamemi_families.html","id":null,"dir":"Reference","previous_headings":"","what":"Make vector of likelihood families — make_inlamemi_families","title":"Make vector of likelihood families — make_inlamemi_families","text":"Make vector likelihood families","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/make_inlamemi_families.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make vector of likelihood families — make_inlamemi_families","text":"","code":"make_inlamemi_families(family_moi, inlamemi_stack)"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/make_inlamemi_families.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make vector of likelihood families — make_inlamemi_families","text":"family_moi string indicating likelihood family model interest (main model). inlamemi_stack object type inla.stack","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/make_inlamemi_families.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make vector of likelihood families — make_inlamemi_families","text":"vector specifying likelihood family model level.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/make_inlamemi_families.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make vector of likelihood families — make_inlamemi_families","text":"","code":"simple_stack <- make_inlamemi_stacks(formula_moi = y ~ x + z,                                      formula_imp = x ~ z,                                      data = simple_data,                                      error_type = c(\"classical\")) make_inlamemi_families(family_moi = \"gaussian\",                        inlamemi_stack = simple_stack) #> [1] \"gaussian\" \"gaussian\" \"gaussian\""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/make_inlamemi_formula.html","id":null,"dir":"Reference","previous_headings":"","what":"Make formula for measurement error and missing data model — make_inlamemi_formula","title":"Make formula for measurement error and missing data model — make_inlamemi_formula","text":"Make formula measurement error missing data model","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/make_inlamemi_formula.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make formula for measurement error and missing data model — make_inlamemi_formula","text":"","code":"make_inlamemi_formula(   formula_moi,   formula_imp,   formula_mis = NULL,   family_moi = \"gaussian\",   error_type = \"classical\",   error_variable = NULL,   prior.beta.error,   prior.gamma.error = NULL,   vars = NULL )"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/make_inlamemi_formula.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make formula for measurement error and missing data model — make_inlamemi_formula","text":"formula_moi object class \"formula\", describing main model fitted. formula_imp object class \"formula\", describing imputation model mismeasured /missing observations. formula_mis object class \"formula\", describing missingness model. need response variable, since always binary missingness indicator. family_moi string indicating likelihood family model interest (main model). error_type type error (one \"classical\", \"berkson\", \"missing\") error_variable character vector name(s) variable(s) error. prior.beta.error parameters prior coefficient error prone variable. TODO: distribution? Gamma? prior.gamma.error parameters prior coefficient variable missingness missingness model. TODO: distribution? Gamma? vars Results call \"extract_variables_from_formula\" function. passed argument, called inside function.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/make_inlamemi_formula.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make formula for measurement error and missing data model — make_inlamemi_formula","text":"object class \"formula\".","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/make_inlamemi_formula.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make formula for measurement error and missing data model — make_inlamemi_formula","text":"","code":"f_moi <- y ~ x + z f_imp <- x ~ z make_inlamemi_formula(formula_moi = f_moi,                       formula_imp = f_imp,                       error_type = \"classical\",                       prior.beta.error = c(0, 1/1000)                       ) #> list(y_moi, x_classical, x_imp) ~ -1 + beta.0 + beta.z + alpha.x.0 +  #>     alpha.x.z + f(beta.x, copy = \"id.x\", hyper = list(beta = list(param = c(0,  #>     0.001), fixed = FALSE))) + f(id.x, weight.x, model = \"iid\",  #>     values = 1:n, hyper = list(prec = list(initial = -15, fixed = TRUE))) #> <environment: 0x56021b8c8d38>"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/make_inlamemi_scaling_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct scaling vector to scale the precision of non-mismeasured observations — make_inlamemi_scaling_vector","title":"Construct scaling vector to scale the precision of non-mismeasured observations — make_inlamemi_scaling_vector","text":"Construct scaling vector scale precision non-mismeasured observations","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/make_inlamemi_scaling_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct scaling vector to scale the precision of non-mismeasured observations — make_inlamemi_scaling_vector","text":"","code":"make_inlamemi_scaling_vector(   inlamemi_stack,   error_type,   classical_error_scaling = NULL,   vars )"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/make_inlamemi_scaling_vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct scaling vector to scale the precision of non-mismeasured observations — make_inlamemi_scaling_vector","text":"inlamemi_stack object class inlamemi.data.stack containing data structured error_type type error (one \"classical\", \"berkson\", \"missing\") classical_error_scaling can specified classical measurement error varies across observations. Must vector length data. vars Results call \"extract_variables_from_formula\" function. passed argument, called inside function.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/make_inlamemi_scaling_vector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct scaling vector to scale the precision of non-mismeasured observations — make_inlamemi_scaling_vector","text":"vector reflecting scaling factor residual terms model level.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/make_inlamemi_scaling_vector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct scaling vector to scale the precision of non-mismeasured observations — make_inlamemi_scaling_vector","text":"","code":"stacks <- make_inlamemi_stacks(data = simple_data,                              formula_moi = y ~ x + z,                              formula_imp = x ~ z,                              error_type = c(\"classical\", \"berkson\")) vars <- extract_variables_from_formula(formula_moi = y ~ x + z,                                        formula_imp = x ~ z) make_inlamemi_scaling_vector(stacks,                            error_type = c(\"classical\", \"berkson\"),                            vars = vars) #>    [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>   [38] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>   [75] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [112] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [149] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [186] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [223] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [260] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [297] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [334] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [371] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [408] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [445] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [482] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [519] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [556] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [593] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [630] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [667] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [704] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [741] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [778] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [815] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [852] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [889] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [926] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  [963] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1000] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1037] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1074] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1111] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1148] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1185] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1222] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1259] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1296] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1333] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1370] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1407] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1444] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1481] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1518] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1555] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1592] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1629] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1666] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1703] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1740] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1777] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1814] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1851] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1888] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1925] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1962] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [1999] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2036] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2073] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2110] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2147] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2184] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2221] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2258] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2295] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2332] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2369] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2406] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2443] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2480] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2517] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2554] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2591] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2628] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2665] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2702] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2739] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2776] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2813] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2850] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2887] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2924] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2961] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [2998] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3035] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3072] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3109] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3146] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3183] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3220] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3257] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3294] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3331] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3368] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3405] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3442] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3479] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3516] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3553] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3590] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3627] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3664] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3701] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3738] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3775] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3812] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3849] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3886] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3923] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3960] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3997] 1 1 1 1"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/make_inlamemi_stacks.html","id":null,"dir":"Reference","previous_headings":"","what":"Make data stacks for joint model specification in INLA — make_inlamemi_stacks","title":"Make data stacks for joint model specification in INLA — make_inlamemi_stacks","text":"Make data stacks joint model specification INLA","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/make_inlamemi_stacks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make data stacks for joint model specification in INLA — make_inlamemi_stacks","text":"","code":"make_inlamemi_stacks(   formula_moi,   formula_imp,   formula_mis = NULL,   family_moi = \"gaussian\",   data,   error_type = \"classical\",   error_variable = NULL,   repeated_observations = FALSE,   vars = NULL )"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/make_inlamemi_stacks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make data stacks for joint model specification in INLA — make_inlamemi_stacks","text":"formula_moi object class \"formula\", describing main model fitted. formula_imp object class \"formula\", describing imputation model mismeasured /missing observations. formula_mis object class \"formula\", describing missingness model. need response variable, since always binary missingness indicator. family_moi string indicating likelihood family model interest (main model). data object class data.frame list containing variables model. error_type type error (one \"classical\", \"berkson\", \"missing\") error_variable character vector name(s) variable(s) error. repeated_observations variable measurement error /missingness repeated observations? , set \"TRUE\". case, specifying formula, use name variable without numbers, specifying data, make sure repeated measurements end number, .e \"sbp1\" \"sbp2\". vars Results call \"extract_variables_from_formula\" function. passed argument, called inside function.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/make_inlamemi_stacks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make data stacks for joint model specification in INLA — make_inlamemi_stacks","text":"object class inla.stack data structured according specified formulas error models.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/make_inlamemi_stacks.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make data stacks for joint model specification in INLA — make_inlamemi_stacks","text":"","code":"make_inlamemi_stacks(formula_moi = y ~ x + z,                    formula_imp = x ~ z,                    data = simple_data,                    error_type = \"classical\") #> Data stack with #>   data:    (y_moi, x_classical, x_imp), size: 3000 #>   effects: (beta.0, beta.x, beta.z, id.x, weight.x, alpha.x.0, alpha.x.z), size: 3000 #>   A:       3000 times 3000 #>   response: 1 response objects"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/mar_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated data with observation missing at random (MAR) — mar_data","title":"Simulated data with observation missing at random (MAR) — mar_data","text":"simulated dataset demonstrate set model case two variables measurement error.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/mar_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated data with observation missing at random (MAR) — mar_data","text":"","code":"mar_data"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/mar_data.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simulated data with observation missing at random (MAR) — mar_data","text":"## `mar_data` data frame 1000 rows 5 columns: y Response variable x Observed value covariate, almost 20 percent missing x_true Correct version x, without missingness z1 Covariate correlated x z2 Covariate correlated missingness x","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/mar_data.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Simulated data with observation missing at random (MAR) — mar_data","text":"dataset simulated.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/nhanes_survival.html","id":null,"dir":"Reference","previous_headings":"","what":"Survival data with repeated systolic blood pressure measurements — nhanes_survival","title":"Survival data with repeated systolic blood pressure measurements — nhanes_survival","text":"dataset containing repeated blood pressure measurement along variables participants Third National Health Nutrition Survey (NHANES III), merged data US National Death Index Ruth H. Keogh Jonathan Bartlett. illustration purposes package, left observations smoking status missing.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/nhanes_survival.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Survival data with repeated systolic blood pressure measurements — nhanes_survival","text":"","code":"nhanes_survival"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/nhanes_survival.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Survival data with repeated systolic blood pressure measurements — nhanes_survival","text":"## `nhanes_survival` data frame 3433 rows 8 columns: sbp1 systolic blood pressure (standardized), first measurement sbp2 systolic blood pressure (standardized), second measurement sex sex (0 = female, 1 = male) age age (standardized) smoke smoking status (0 = , 1 = yes) diabetes diabetes status (0 = , 1 = yes) d censoring status (0 = censored, 1 = observed death due cardiovascular disease) t time death due cardiovascular disease occurs","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/nhanes_survival.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Survival data with repeated systolic blood pressure measurements — nhanes_survival","text":"https://github.com/ruthkeogh/meas_error_handbook","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/plot.inlamemi.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot model summary — plot.inlamemi","title":"Plot model summary — plot.inlamemi","text":"Plot model summary","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/plot.inlamemi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot model summary — plot.inlamemi","text":"","code":"# S3 method for inlamemi plot(   x,   plot_moi = TRUE,   plot_imp = TRUE,   plot_mis = TRUE,   plot_intercepts = TRUE,   error_variable_highlight = FALSE,   greek = FALSE,   palette = NULL,   ... )"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/plot.inlamemi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot model summary — plot.inlamemi","text":"x model returned fit_inlamemi function. plot_moi posterior mean coefficients model interest plotted? Defaults TRUE. plot_imp posterior mean coefficients imputation model plotted? Defaults TRUE. plot_mis posterior mean coefficients missingness model plotted? Defaults TRUE. plot_intercepts posterior mean intercept(s) plotted? Defaults TRUE. error_variable_highlight coefficient(s) variable(s) error highlighted? (circled black) Defaults FALSE. greek make coefficient names greek letters covariate name subscript. Defaults FALSE. palette either number (1 5), indicating number color palette used, vector colors used. ... arguments","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/plot.inlamemi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot model summary — plot.inlamemi","text":"object class \"ggplot2\" plots posterior mean 95 % credible interval coefficient model. coefficients colored indicate belong main imputation model, variable error also highlighted.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/plot.inlamemi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot model summary — plot.inlamemi","text":"","code":"simple_moi <- y ~ x + z simple_imp <- x ~ z  # Fit the model simple_model <- fit_inlamemi(data = simple_data,                            formula_moi = simple_moi,                            formula_imp = simple_imp,                            family_moi = \"gaussian\",                            error_type = c(\"berkson\", \"classical\"),                            prior.prec.moi = c(10, 9),                            prior.prec.berkson = c(10, 9),                            prior.prec.classical = c(10, 9),                            prior.prec.imp = c(10, 9),                            prior.beta.error = c(0, 1/1000),                            initial.prec.moi = 1,                            initial.prec.berkson = 1,                            initial.prec.classical = 1,                            initial.prec.imp = 1)  plot(simple_model)"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/show_data_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize the model data structure as matrices — show_data_structure","title":"Visualize the model data structure as matrices — show_data_structure","text":"Visualize model data structure matrices","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/show_data_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize the model data structure as matrices — show_data_structure","text":"","code":"show_data_structure(stack)"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/show_data_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize the model data structure as matrices — show_data_structure","text":"stack object class inla.stack returned function make_inlamemi_stacks, describes structure data measurement error imputation model.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/show_data_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize the model data structure as matrices — show_data_structure","text":"list containing data frames left hand side (response_df) right hand side (effects_df), along latex code needed visualize matrices (matrix_string).","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/show_data_structure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize the model data structure as matrices — show_data_structure","text":"","code":"f_moi <- y ~ x + z f_imp <- x ~ z stack <- make_inlamemi_stacks(data = simple_data,                    formula_moi = f_moi,                    formula_imp = f_imp,                    error_type = \"classical\") show_data_structure(stack) #> $response_df #>        y_moi x_classical   x_imp #> 1      10.81        <NA>    <NA> #> 2    \\\\vdots     \\\\vdots \\\\vdots #> 1000    6.18        <NA>    <NA> #> 1001    <NA>        4.98    <NA> #> 5    \\\\vdots     \\\\vdots \\\\vdots #> 2000    <NA>        1.46    <NA> #> 2001    <NA>        <NA>       0 #> 8    \\\\vdots     \\\\vdots \\\\vdots #> 3000    <NA>        <NA>       0 #>  #> $effects_df #>       beta.0  beta.x  beta.z    id.x weight.x alpha.x.0 alpha.x.z #> 1          1       1    0.98    <NA>     <NA>      <NA>      <NA> #> 2    \\\\vdots \\\\vdots \\\\vdots \\\\vdots  \\\\vdots   \\\\vdots   \\\\vdots #> 1000       1    1000    0.77    <NA>     <NA>      <NA>      <NA> #> 1001    <NA>    <NA>    <NA>       1        1      <NA>      <NA> #> 5    \\\\vdots \\\\vdots \\\\vdots \\\\vdots  \\\\vdots   \\\\vdots   \\\\vdots #> 2000    <NA>    <NA>    <NA>    1000        1      <NA>      <NA> #> 2001    <NA>    <NA>    <NA>      -1       -1         1      0.98 #> 8    \\\\vdots \\\\vdots \\\\vdots \\\\vdots  \\\\vdots   \\\\vdots   \\\\vdots #> 3000    <NA>    <NA>    <NA>   -1000       -1         1      0.77 #>  #> $matrix_string #> [1] \"$$\\\\underbrace{\\\\begin{bmatrix} \\n10.81 & \\\\texttt{NA} & \\\\texttt{NA}\\\\\\\\\\n\\\\vdots & \\\\vdots & \\\\vdots\\\\\\\\\\n6.18 & \\\\texttt{NA} & \\\\texttt{NA}\\\\\\\\\\n\\\\texttt{NA} & 4.98 & \\\\texttt{NA}\\\\\\\\\\n\\\\vdots & \\\\vdots & \\\\vdots\\\\\\\\\\n\\\\texttt{NA} & 1.46 & \\\\texttt{NA}\\\\\\\\\\n\\\\texttt{NA} & \\\\texttt{NA} & 0\\\\\\\\\\n\\\\vdots & \\\\vdots & \\\\vdots\\\\\\\\\\n\\\\texttt{NA} & \\\\texttt{NA} & 0\\\\\\\\\\n\\\\end{bmatrix}}_{\\\\texttt{Y}}\\n = \\n\\\\beta_{0}\\\\underbrace{\\\\begin{bmatrix} \\n1\\\\\\\\\\n\\\\vdots\\\\\\\\\\n1\\\\\\\\\\n\\\\texttt{NA}\\\\\\\\\\n\\\\vdots\\\\\\\\\\n\\\\texttt{NA}\\\\\\\\\\n\\\\texttt{NA}\\\\\\\\\\n\\\\vdots\\\\\\\\\\n\\\\texttt{NA}\\\\\\\\\\n\\\\end{bmatrix}}_{\\\\texttt{beta.0}} + \\\\beta_{x}\\\\underbrace{\\\\begin{bmatrix} \\n1\\\\\\\\\\n\\\\vdots\\\\\\\\\\n1000\\\\\\\\\\n\\\\texttt{NA}\\\\\\\\\\n\\\\vdots\\\\\\\\\\n\\\\texttt{NA}\\\\\\\\\\n\\\\texttt{NA}\\\\\\\\\\n\\\\vdots\\\\\\\\\\n\\\\texttt{NA}\\\\\\\\\\n\\\\end{bmatrix}}_{\\\\texttt{beta.x}} + \\\\beta_{z}\\\\underbrace{\\\\begin{bmatrix} \\n0.98\\\\\\\\\\n\\\\vdots\\\\\\\\\\n0.77\\\\\\\\\\n\\\\texttt{NA}\\\\\\\\\\n\\\\vdots\\\\\\\\\\n\\\\texttt{NA}\\\\\\\\\\n\\\\texttt{NA}\\\\\\\\\\n\\\\vdots\\\\\\\\\\n\\\\texttt{NA}\\\\\\\\\\n\\\\end{bmatrix}}_{\\\\texttt{beta.z}} + \\\\underbrace{\\\\begin{bmatrix} \\n\\\\texttt{NA}\\\\\\\\\\n\\\\vdots\\\\\\\\\\n\\\\texttt{NA}\\\\\\\\\\n1\\\\\\\\\\n\\\\vdots\\\\\\\\\\n1000\\\\\\\\\\n-1\\\\\\\\\\n\\\\vdots\\\\\\\\\\n-1000\\\\\\\\\\n\\\\end{bmatrix}}_{\\\\texttt{id.x}} + \\\\alpha_{x,0}\\\\underbrace{\\\\begin{bmatrix} \\n\\\\texttt{NA}\\\\\\\\\\n\\\\vdots\\\\\\\\\\n\\\\texttt{NA}\\\\\\\\\\n\\\\texttt{NA}\\\\\\\\\\n\\\\vdots\\\\\\\\\\n\\\\texttt{NA}\\\\\\\\\\n1\\\\\\\\\\n\\\\vdots\\\\\\\\\\n1\\\\\\\\\\n\\\\end{bmatrix}}_{\\\\texttt{alpha.x.0}} + \\\\alpha_{x,z}\\\\underbrace{\\\\begin{bmatrix} \\n\\\\texttt{NA}\\\\\\\\\\n\\\\vdots\\\\\\\\\\n\\\\texttt{NA}\\\\\\\\\\n\\\\texttt{NA}\\\\\\\\\\n\\\\vdots\\\\\\\\\\n\\\\texttt{NA}\\\\\\\\\\n0.98\\\\\\\\\\n\\\\vdots\\\\\\\\\\n0.77\\\\\\\\\\n\\\\end{bmatrix}}_{\\\\texttt{alpha.x.z}}$$\" #>"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/simple_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Simple simulated data — simple_data","title":"Simple simulated data — simple_data","text":"simulated dataset demonstrate model different types measurement error missing data using 'inlamemi' package.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/simple_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simple simulated data — simple_data","text":"","code":"simple_data"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/simple_data.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simple simulated data — simple_data","text":"## `simple_data` data frame 1000 rows 4 columns: y Response variable x Covariate measured error, Berkson classical error missing observations x_true Correct version covariate error z Error free covariate, correlated x","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/simple_data.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Simple simulated data — simple_data","text":"dataset simulated.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/simplify_inlamemi_model_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Simplify the ","title":"Simplify the ","text":"Simplify \"raw\" model summary printing plotting","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/simplify_inlamemi_model_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simplify the ","text":"","code":"simplify_inlamemi_model_summary(inlamemi_model)"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/simplify_inlamemi_model_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simplify the ","text":"inlamemi_model model returned fit_inlamemi function.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/simplify_inlamemi_model_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simplify the ","text":"list four data frames, containing summaries different components model. coefficients model interest, coefficient variable error, coefficients imputation model, hyperparameters.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for inlamemi — summary.inlamemi","title":"Summary method for inlamemi — summary.inlamemi","text":"Takes fitted `inlamemi` object produced `fit_inlamemi` produces summary .","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for inlamemi — summary.inlamemi","text":"","code":"# S3 method for inlamemi summary(object, ...)  # S3 method for summary.inlamemi print(x, ...)"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for inlamemi — summary.inlamemi","text":"object model class `inlamemi`. ... arguments x object class summary.inlamemi.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for inlamemi — summary.inlamemi","text":"`summary.inlamemi` returns object class `summary.inlamemi`, list components print.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary method for inlamemi — summary.inlamemi","text":"","code":"simple_moi <- y ~ x + z simple_imp <- x ~ z  # Fit the model simple_model <- fit_inlamemi(data = simple_data,                            formula_moi = simple_moi,                            formula_imp = simple_imp,                            family_moi = \"gaussian\",                            error_type = c(\"berkson\", \"classical\"),                            prior.prec.moi = c(10, 9),                            prior.prec.berkson = c(10, 9),                            prior.prec.classical = c(10, 9),                            prior.prec.imp = c(10, 9),                            prior.beta.error = c(0, 1/1000),                            initial.prec.moi = 1,                            initial.prec.berkson = 1,                            initial.prec.classical = 1,                            initial.prec.imp = 1)  summary(simple_model) #> Formula for model of interest:  #> y ~ x + z #>  #> Formula for imputation model:  #> x ~ z #>  #> Error types:  #> [1] \"berkson\"   \"classical\" #>  #> Fixed effects for model of interest:  #>            mean        sd 0.025quant 0.5quant 0.975quant      mode #> beta.0 1.025611 0.2178430  0.6054249 1.023519   1.426496 0.9835037 #> beta.z 1.902346 0.3861013  1.2061681 1.886838   2.541363 1.8972488 #>  #> Coefficient for variable with measurement error and/or missingness:  #>            mean        sd 0.025quant 0.5quant 0.975quant     mode #> beta.x 1.973033 0.2022895   1.565369 1.976224   2.361729 1.989975 #>  #> Fixed effects for imputation model:  #>               mean         sd 0.025quant 0.5quant 0.975quant     mode #> alpha.x.0 1.033083 0.05061486  0.9337864 1.033091   1.132335 1.033091 #> alpha.x.z 2.024700 0.05227802  1.9222130 2.024683   2.127286 2.024683 #>  #> Model hyperparameters (apart from beta.x):  #>                                      mean        sd 0.025quant  0.5quant #> Precision for model of interest 1.1335268 0.3655006  0.5697471 1.0823183 #> Precision for x berkson model   1.1286853 0.3422449  0.5904240 1.0839322 #> Precision for x classical model 0.9232180 0.1074532  0.7335241 0.9157795 #> Precision for x imp model       0.9789172 0.1249604  0.7525828 0.9722038 #>                                 0.975quant      mode #> Precision for model of interest   1.992597 0.9878885 #> Precision for x berkson model     1.924456 1.0017508 #> Precision for x classical model   1.156041 0.8986439 #> Precision for x imp model         1.243694 0.9611651 #>"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/two_error_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated data with two covariates with classical measurement error — two_error_data","title":"Simulated data with two covariates with classical measurement error — two_error_data","text":"simulated dataset demonstrate set model case two variables measurement error.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/two_error_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated data with two covariates with classical measurement error — two_error_data","text":"","code":"two_error_data"},{"path":"https://emmaskarstein.github.io/inlamemi/reference/two_error_data.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simulated data with two covariates with classical measurement error — two_error_data","text":"## `two_error_data` data frame 1000 rows 5 columns: y Response variable x1 Covariate measured classical error, correlated z x2 Covariate measured classical error x1_true Correct version x1 x2_true Correct version x2 z Error free covariate, correlated x1","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/reference/two_error_data.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Simulated data with two covariates with classical measurement error — two_error_data","text":"dataset simulated.","code":""},{"path":"https://emmaskarstein.github.io/inlamemi/news/index.html","id":"inlamemi-100","dir":"Changelog","previous_headings":"","what":"inlamemi 1.0.0","title":"inlamemi 1.0.0","text":"Initial CRAN submission.","code":""}]
